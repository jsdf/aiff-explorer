{"version":3,"sources":["App.js","aiff.js","Details.js","index.js","ieeeextended.js","bufferstruct.js"],"names":["readFile","file","Promise","resolve","reject","reader","FileReader","readAsArrayBuffer","addEventListener","result","error","boxStyle","border","textStyle","margin","wordWrap","textStyleFlushLeft","DisplayObject","object","style","Object","keys","map","key","value","Array","isArray","v","i","length","JSON","stringify","AiffChunk","chunk","ckID","ckSize","localChunks","chunkSpecificData","parsed","formType","startOpen","summary","summaryStyle","width","cursor","fontWeight","lchunk","fontSize","color","App","useState","aiff","setAiff","setError","handleFiles","useCallback","e","a","fileList","currentTarget","files","data","AIFF","Buffer","includeRawChunks","err","className","type","id","onChange","height","display","padding","toString","fileChunks","href","ieeeExtended","require","BufferStruct","BufferStructBase","BufferStructUnion","PString","constructor","super","name","parse","buffer","startOffset","contextData","readUInt8","str","slice","consumed","size","alignment","Math","ceil","this","lastOffset","serialize","Error","getName","parts","from","push","alloc","concat","AIFFChunkStruct","endian","fields","chunkData","align","AIFFCommonStruct","numChannels","numSampleFrames","sampleSize","sampleRate","AIFCCommonStruct","compressionType","compressionName","AIFCApplicationSpecificStruct","applicationSignature","context","dataSize","AIFFSoundDataStruct","offset","blockSize","soundData","soundDataSize","AIFFMarkerIdField","AIFFMarkerStruct","position","markerName","AIFFMarkerChunkStruct","numMarkers","markers","arrayElements","AIFFCommentStruct","timeStamp","marker","count","text","AIFFLoopStruct","playMode","beginLoop","endLoop","AIFFInstrumentStruct","baseNote","detune","lowNote","highNote","lowVelocity","highVelocity","gain","sustainLoop","releaseLoop","AIFFNameChunkID","AIFFAuthorChunkID","AIFFCopyrightChunkID","AIFFAnnotationChunkID","AIFFTextStruct","_","AIFCFormatStruct","timestamp","makeAIFFChunk","module","exports","chunks","rawChunks","nsamples","floor","sampleRate80Bit","ConvertToIeeeExtended","formatChunk","commChunk","soundDataChunk","serializedChunks","forEach","parsedChunk","serialized","formTypeSerialized","filter","Boolean","fileContents","options","pos","output","parsedFormLocalChunks","endOffset","fileChunk","formChunk","ConvertFromIeeeExtended","LoopPlayMode","NoLooping","ForwardLooping","ForwardBackwardLooping","Details","children","React","open","setOpen","onToggle","preventDefault","stopPropagation","onClick","rootElement","document","getElementById","ReactDOM","render","ldexp","x","exp","pow","FloatToUnsigned","f","UnsignedToFloat","u","bytes","expon","hiMant","loMant","Infinity","num","sign","fMant","fsMant","fill","frexpRes","arg","Number","isFinite","absArg","abs","log2","n","log","LOG2E","max","frexp","nullthrows","message","nanthrows","isNaN","FieldTypesToBufferMethods","uint","int","float","double","bigint","biguint","char","BytesTypes","Set","getBufferMethodName","getAlignedSize","getAlignedSizeForField","field","schema","getStaticSize","members","selectMember","m","_staticSize","partialResult","fieldName","_getFieldConfig","has","valueAsBuffer","parsedSize","methodName","traceReads","console","parseWithAlignment","parsedSizeWithAlignment","alignedExpectedSize","consumedSize","array","partialFieldData","actualType","default","dynSize","partBuffer","copy","traceWrites","serializeWithAlignment","serializedSize","maybeAlignedPartBuffer","alignedSerializedSize","partBufferAligned","part","prevSize","values"],"mappings":"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","file":"static/js/main.1530fc60.chunk.js","sourcesContent":["import './styles.css';\nimport * as AIFF from './aiff';\nimport {useState, useCallback} from 'react';\nimport Details from './Details';\n\nfunction readFile(file) {\n  return new Promise((resolve, reject) => {\n    const reader = new FileReader();\n    reader.readAsArrayBuffer(file);\n    reader.addEventListener('load', () => {\n      resolve(reader.result);\n    });\n    reader.addEventListener('error', () => {\n      reject(reader.error);\n    });\n  });\n}\n\nconst boxStyle = {\n  border: 'solid 1px black',\n};\nconst textStyle = {\n  margin: '8px 8px',\n  wordWrap: 'break-word',\n};\nconst textStyleFlushLeft = {\n  margin: '8px 0',\n  wordWrap: 'break-word',\n};\n\nfunction DisplayObject({object}) {\n  return (\n    <div style={{...boxStyle, margin: '8px 0px'}}>\n      {Object.keys(object).map((key) => {\n        const value = object[key];\n        if (value && typeof value === 'object') {\n          if (Array.isArray(value)) {\n            return (\n              <div key={key} style={textStyle}>\n                {key}:{' '}\n                {value.map((v, i) => (\n                  <DisplayObject key={i} object={v} />\n                ))}\n              </div>\n            );\n          }\n          if (typeof value.length === 'number') {\n            return (\n              <div key={key} style={textStyle}>\n                {key}: {`Buffer {size: ${value.length}}`}\n              </div>\n            );\n          }\n          return (\n            <div key={key} style={textStyle}>\n              {key}: <DisplayObject object={value} />\n            </div>\n          );\n        }\n        return (\n          <div key={key} style={textStyle}>\n            {key}: {JSON.stringify(value)}\n          </div>\n        );\n      })}\n    </div>\n  );\n}\n\nfunction AiffChunk({chunk}) {\n  const {ckID, ckSize, localChunks} = chunk;\n  let chunkSpecificData = chunk.parsed;\n  if (ckID === 'FORM') {\n    chunkSpecificData = {formType: chunk.formType};\n  }\n\n  return (\n    <div style={{...boxStyle, margin: '8px 0px'}}>\n      <Details\n        style={textStyle}\n        startOpen\n        summary={ckID}\n        summaryStyle={{\n          width: '100%',\n          cursor: 'pointer',\n          fontWeight: 'bold',\n        }}\n      >\n        <div style={textStyleFlushLeft}>chunk size: {ckSize}</div>\n        {chunkSpecificData && (\n          <div style={textStyleFlushLeft}>\n            {ckID} fields:{' '}\n            {typeof chunkSpecificData === 'object' ? (\n              <DisplayObject object={chunkSpecificData} />\n            ) : (\n              JSON.stringify(chunkSpecificData)\n            )}\n          </div>\n        )}\n        {localChunks && (\n          <div style={textStyleFlushLeft}>\n            local chunks:\n            {localChunks.map((lchunk, i) => (\n              <AiffChunk key={i} chunk={lchunk} />\n            ))}\n          </div>\n        )}\n        <div style={{...textStyleFlushLeft, fontSize: '0.8em', color: '#777'}}>\n          end {ckID} chunk\n        </div>\n      </Details>\n    </div>\n  );\n}\n\nexport default function App() {\n  const [aiff, setAiff] = useState(null);\n  const [error, setError] = useState(null);\n\n  const handleFiles = useCallback(async function handleFiles(e) {\n    const fileList =\n      e.currentTarget.files; /* now you can work with the file list */\n\n    const data = await readFile(fileList[0]);\n    try {\n      setAiff(AIFF.parse(new Buffer(data), {includeRawChunks: true}));\n      setError(null);\n    } catch (err) {\n      setAiff(null);\n      setError(err);\n    }\n  }, []);\n\n  return (\n    <div className=\"App\">\n      <h1>AIFF explorer</h1>\n      <div>\n        <p>This tool visualizes the chunks in an AIFF file.</p>\n        <input\n          type=\"file\"\n          id=\"input\"\n          onChange={handleFiles}\n          style={{\n            cursor: 'pointer',\n            height: aiff ? null : 300,\n            width: aiff ? null : 600,\n            display: aiff ? null : 'block',\n            border: 'dashed #aaa 1px',\n            padding: 16,\n          }}\n        />\n      </div>\n\n      {error && (\n        <p>\n          Error: this is probably not a valid AIFF file ({error.toString()})\n        </p>\n      )}\n      {aiff &&\n        aiff.fileChunks.map((chunk, i) => <AiffChunk key={i} chunk={chunk} />)}\n      {!(aiff || error) && (\n        <div>\n          <p>\n            Select (or drag and drop) an .aif, .aiff, or .aifc file to begin.\n          </p>\n          <p>\n            Some sample files can be found{' '}\n            <a href=\"http://www-mmsp.ece.mcgill.ca/Documents/AudioFormats/AIFF/Samples.html\">\n              here\n            </a>\n            . Info about the AIFF specification can be found{' '}\n            <a href=\"http://www-mmsp.ece.mcgill.ca/Documents/AudioFormats/AIFF/AIFF.html\">\n              here\n            </a>\n            .\n          </p>\n        </div>\n      )}\n    </div>\n  );\n}\n","const ieeeExtended = require('./ieeeextended');\nconst {\n  BufferStruct,\n  BufferStructUnion,\n  BufferStructBase,\n} = require('./bufferstruct');\n\nconst DEBUG = false;\n\nfunction getAlignedSize(size, alignment) {\n  return Math.ceil(size / alignment) * alignment;\n}\n\n// pascal-style string\nclass PStringParser extends BufferStructBase {\n  constructor() {\n    super({name: 'PString'});\n  }\n  parse(buffer, startOffset, contextData = null) {\n    const length = buffer.readUInt8(startOffset);\n\n    const str = buffer\n      .slice(startOffset + 1, startOffset + 1 + length)\n      .toString('utf8');\n\n    const consumed = getAlignedSize(1 + length, 2); // pad to multiple of 2\n\n    this.lastOffset = startOffset + consumed;\n    return str;\n  }\n\n  serialize(data, contextData = null) {\n    if (!data) {\n      throw new Error(\n        `missing argument 'data' when serializing ${this.getName()}`\n      );\n    }\n\n    const parts = [Buffer.from([data.length]), Buffer.from(data)];\n\n    // pad to even size\n    if ((1 + data.length) % 2 === 1) {\n      parts.push(Buffer.alloc(1));\n    }\n\n    return Buffer.concat(parts);\n  }\n}\n\nconst PString = new PStringParser();\n\n// AIFF stuff\n// http://paulbourke.net/dataformats/audio/\n// http://www-mmsp.ece.mcgill.ca/Documents/AudioFormats/AIFF/Docs/AIFF-1.3.pdf\n// http://www-mmsp.ece.mcgill.ca/Documents/AudioFormats/AIFF/Docs/AIFF-C.9.26.91.pdf\nconst AIFFChunkStruct = new BufferStruct({\n  name: 'AIFFChunk',\n  endian: 'big',\n  fields: {\n    ckID: {type: 'utf8', size: 4},\n    ckSize: {type: 'int', size: 4},\n    chunkData: {type: 'bytes', align: 2, size: (fields) => fields.ckSize},\n  },\n});\n\n// short numChannels;\n// unsigned long numSampleFrames;\n// short sampleSize;\n// extended sampleRate;\nconst AIFFCommonStruct = new BufferStruct({\n  name: 'AIFFCommon',\n  endian: 'big',\n  fields: {\n    numChannels: {type: 'int', size: 2},\n    numSampleFrames: {type: 'uint', size: 4},\n    sampleSize: {type: 'int', size: 2},\n    sampleRate: {type: 'bytes', size: 10},\n  },\n});\n\n// short numChannels; /* # audio channels */\n// unsigned long numSampleFrames; /* # sample frames = samples/channel */\n// short sampleSize; /* # bits/sample */\n// extended sampleRate; /* sample_frames/sec */\n// ID compressionType; /* compression type ID code */\n// pstring compressionName; /* human-readable compression type name */\nconst AIFCCommonStruct = new BufferStruct({\n  name: 'AIFCCommon',\n  endian: 'big',\n  fields: {\n    numChannels: {type: 'int', size: 2},\n    numSampleFrames: {type: 'uint', size: 4},\n    sampleSize: {type: 'int', size: 2},\n    sampleRate: {type: 'bytes', size: 10},\n    compressionType: {type: 'utf8', size: 4},\n    compressionName: {type: PString},\n  },\n});\n\n// #define ApplicationSpecificID 'APPL' /* ckID for Application Specific Chunk */\n// typedef struct {\n// ID ckID; /* 'APPL' */\n// long ckDataSize;\n// OSType applicationSignature;\n// char data[];\n// } ApplicationSpecificChunk;\nconst AIFC_APPL_CHUNK_SIZE_EXCL_DATA = 4; // sum of fixed-size fields\nconst AIFCApplicationSpecificStruct = new BufferStruct({\n  name: 'AIFCApplicationSpecific',\n  endian: 'big',\n  fields: {\n    applicationSignature: {type: 'utf8', size: 4},\n    data: {\n      type: 'bytes',\n      size: (fields, context) => context.dataSize,\n    },\n  },\n});\n\n// unsigned long offset;\n// unsigned long blockSize;\nconst AIFF_SOUND_DATA_CHUNK_SIZE_EXCL_SOUNDDATA = 8; // sum of fixed-size fields\nconst AIFFSoundDataStruct = new BufferStruct({\n  name: 'AIFFSoundData',\n  endian: 'big',\n  fields: {\n    offset: {type: 'uint', size: 4},\n    blockSize: {type: 'uint', size: 4},\n    soundData: {\n      type: 'bytes',\n      size: (fields, context) => context.soundDataSize,\n    },\n  },\n});\n\n// typedef short MarkerId;\nconst AIFFMarkerIdField = {type: 'int', size: 2};\n//   typedef struct {\n//   MarkerId id; /* must be > 0 */\n//   unsigned long position; /* sample frame number */\n//   pstring markerName;\n// } Marker;\nconst AIFFMarkerStruct = new BufferStruct({\n  name: 'AIFFMarker',\n  endian: 'big',\n  fields: {\n    id: AIFFMarkerIdField,\n    position: {type: 'uint', size: 4},\n    markerName: {type: PString},\n  },\n});\n\n// typedef struct {\n//   ID ckID;\n//   long ckSize;\n//   unsigned short numMarkers;\n//   Marker Markers[];\n// } MarkerChunk;\nconst AIFFMarkerChunkStruct = new BufferStruct({\n  name: 'AIFFMarkerChunk',\n  endian: 'big',\n  fields: {\n    numMarkers: {type: 'uint', size: 2},\n    markers: {\n      type: AIFFMarkerStruct,\n      arrayElements: (fields) => fields.numMarkers,\n    },\n  },\n});\n\n// typedef struct {\n//   unsigned long timeStamp; /* comment creation date */\n//   MarkerId marker; /* comments for this marker number */\n//   unsigned short count; /* comment text string length */\n//   char text[]; /* comment text */\n// } Comment;\nconst AIFFCommentStruct = new BufferStruct({\n  name: 'AIFFComment',\n  endian: 'big',\n  fields: {\n    timeStamp: {type: 'uint', size: 4},\n    marker: AIFFMarkerIdField,\n    count: {type: 'uint', size: 2},\n    text: {type: 'utf8', size: (fields) => fields.count},\n  },\n});\n\nconst LoopPlayMode = {\n  NoLooping: 0,\n  ForwardLooping: 1,\n  ForwardBackwardLooping: 2,\n};\n\n// typedef struct {\n//   short playMode;\n//   MarkerId beginLoop;\n//   MarkerId endLoop;\n// } Loop;\nconst AIFFLoopStruct = new BufferStruct({\n  name: 'AIFFLoop',\n  endian: 'big',\n  fields: {\n    playMode: {type: 'int', size: 2},\n    beginLoop: AIFFMarkerIdField,\n    endLoop: AIFFMarkerIdField,\n  },\n});\n\n// typedef struct {\n//   char baseNote;\n//   char detune;\n//   char lowNote;\n//   char highNote;\n//   char lowVelocity;\n//   char highVelocity;\n//   short gain;\n//   Loop sustainLoop;\n//   Loop releaseLoop;\n// } InstrumentChunk;\nconst AIFFInstrumentStruct = new BufferStruct({\n  name: 'AIFFInstrument',\n  endian: 'big',\n  fields: {\n    baseNote: {type: 'int', size: 1},\n    detune: {type: 'int', size: 1},\n    lowNote: {type: 'int', size: 1},\n    highNote: {type: 'int', size: 1},\n    lowVelocity: {type: 'int', size: 1},\n    highVelocity: {type: 'int', size: 1},\n    gain: {type: 'int', size: 2},\n    sustainLoop: {type: AIFFLoopStruct},\n    releaseLoop: {type: AIFFLoopStruct},\n  },\n});\nconst AIFFNameChunkID = 'NAME'; /* ckID for Name Chunk */\nconst AIFFAuthorChunkID = 'AUTH'; /* ckID for Author Chunk */\nconst AIFFCopyrightChunkID = '(c) '; /* ckID for Copyright Chunk */\nconst AIFFAnnotationChunkID = 'ANNO'; /* ckID for Annotation Chunk */\n// typedef struct {\n//   ID ckID;\n//   long ckDataSize;\n//   char text[];\n// } TextChunk;\nconst AIFFTextStruct = new BufferStruct({\n  name: 'AIFFText',\n  endian: 'big',\n  fields: {\n    text: {type: 'utf8', size: (_, context) => context.dataSize},\n  },\n});\n\nconst AIFCVersion1 = 0xa2805140; /* Version 1 of AIFF-C */\n\nconst AIFCFormatStruct = new BufferStruct({\n  name: 'AIFCFormat',\n  endian: 'big',\n  fields: {\n    timestamp: {type: 'uint', size: 4},\n  },\n});\n\nfunction makeAIFFChunk(ckID, chunkData) {\n  return AIFFChunkStruct.serialize({\n    ckID,\n    ckSize: chunkData.length,\n    chunkData,\n  });\n}\n\nfunction serializeAIFF({\n  soundData,\n  numChannels,\n  sampleRate,\n  sampleSize,\n  formType,\n  compressionType,\n  compressionName,\n  chunks,\n  rawChunks,\n}) {\n  const nsamples = Math.floor(\n    soundData.length / numChannels / (sampleSize / 8)\n  );\n  const sampleRate80Bit = Buffer.from(\n    ieeeExtended.ConvertToIeeeExtended(sampleRate)\n  );\n  DEBUG && console.log({sampleRate, sampleRate80Bit});\n\n  const formatChunk =\n    formType === 'AIFC'\n      ? makeAIFFChunk(\n          'FVER',\n          AIFCFormatStruct.serialize({\n            timestamp: AIFCVersion1,\n          })\n        )\n      : null;\n\n  const commChunk = makeAIFFChunk(\n    'COMM',\n    formType === 'AIFC'\n      ? AIFCCommonStruct.serialize({\n          numChannels,\n          numSampleFrames: nsamples,\n          sampleSize,\n          sampleRate: sampleRate80Bit,\n          compressionType,\n          compressionName,\n        })\n      : AIFFCommonStruct.serialize({\n          numChannels,\n          numSampleFrames: nsamples,\n          sampleSize,\n          sampleRate: sampleRate80Bit,\n        })\n  );\n\n  const soundDataChunk = makeAIFFChunk(\n    'SSND',\n    AIFFSoundDataStruct.serialize(\n      {\n        offset: 0,\n        blockSize: 0,\n        soundData,\n      },\n      {soundDataSize: soundData.length}\n    )\n  );\n\n  const serializedChunks = [];\n  (chunks || []).forEach((parsedChunk) => {\n    const data = parsedChunk.data;\n    let serialized;\n    switch (parsedChunk.type) {\n      case 'SSND':\n      case 'FVER':\n      case 'COMM':\n        return;\n      case 'APPL':\n        serialized = AIFCApplicationSpecificStruct.serialize(data, {\n          dataSize: data.data.length,\n        });\n        break;\n      case 'MARK':\n        serialized = AIFFMarkerChunkStruct.serialize(data);\n        break;\n      case 'COMT':\n        serialized = AIFFCommentStruct.serialize(data);\n        break;\n      case 'INST':\n        serialized = AIFFInstrumentStruct.serialize(data);\n        break;\n      case AIFFNameChunkID:\n      case AIFFAuthorChunkID:\n      case AIFFCopyrightChunkID:\n      case AIFFAnnotationChunkID:\n        serialized = AIFFTextStruct.serialize(data, {\n          dataSize: data.text.length,\n        });\n        break;\n    }\n    if (serialized) {\n      serializedChunks.push(makeAIFFChunk(parsedChunk.type, serialized));\n    }\n  });\n\n  const formTypeSerialized = Buffer.from(\n    formType === 'AIFC' ? 'AIFC' : 'AIFF',\n    'utf8'\n  );\n\n  const aiffFileContents = makeAIFFChunk(\n    'FORM',\n    Buffer.concat(\n      [\n        formTypeSerialized,\n        formatChunk,\n        commChunk,\n        soundDataChunk,\n        ...serializedChunks,\n        ...(rawChunks || []),\n      ].filter(Boolean)\n    )\n  );\n\n  return aiffFileContents;\n}\n\nfunction parseAIFF(fileContents, options = {}) {\n  let pos = 0;\n\n  let output = {};\n\n  const fileChunks = [];\n  const parsedFormLocalChunks = [];\n\n  while (pos < fileContents.length) {\n    DEBUG &&\n      console.log(\n        'parsing file chunk',\n        fileContents.slice(pos, pos + 4).toString('utf8'),\n        'at',\n        pos,\n        {fileContents}\n      );\n    const chunk = AIFFChunkStruct.parse(fileContents, pos);\n    chunk.startOffset = pos;\n    chunk.endOffset = AIFFChunkStruct.lastOffset;\n    fileChunks.push(chunk);\n    pos = AIFFChunkStruct.lastOffset;\n  }\n\n  DEBUG && console.log(fileChunks);\n\n  const formChunks = fileChunks.filter(\n    (fileChunk) => fileChunk.ckID === 'FORM'\n  );\n  formChunks.forEach((formChunk) => {\n    let pos = 0;\n    DEBUG && console.log('FORM chunk', formChunk);\n    const formType = formChunk.chunkData.slice(0, 4).toString('utf8');\n    formChunk.formType = formType;\n\n    if (formType === 'AIFF' || formType === 'AIFC') {\n      output.formType = formType;\n    }\n    pos += 4; // skip FORM identifier\n    DEBUG && console.log({formType});\n\n    const localChunks = [];\n    while (pos < formChunk.chunkData.length) {\n      DEBUG &&\n        console.log(\n          'parsing FORM local chunk',\n          formChunk.chunkData.slice(pos, pos + 4),\n          'at',\n          pos\n        );\n      const chunk = AIFFChunkStruct.parse(formChunk.chunkData, pos);\n      chunk.startOffset = pos;\n      chunk.endOffset = AIFFChunkStruct.lastOffset;\n\n      if (chunk.ckSize === 0) {\n        DEBUG &&\n          console.error(\n            'zero size chunk',\n            formChunk.chunkData.slice(pos, pos + 64)\n          );\n      }\n      switch (chunk.ckID) {\n        case 'COMM':\n          chunk.parsed =\n            formType === 'AIFC'\n              ? AIFCCommonStruct.parse(chunk.chunkData)\n              : AIFFCommonStruct.parse(chunk.chunkData);\n          chunk.parsed.sampleRate = ieeeExtended.ConvertFromIeeeExtended(\n            chunk.parsed.sampleRate\n          );\n\n          output.sampleRate = chunk.parsed.sampleRate;\n          output.sampleSize = chunk.parsed.sampleSize;\n          output.numChannels = chunk.parsed.numChannels;\n          output.compressionType = chunk.parsed.compressionType;\n          output.compressionName = chunk.parsed.compressionName;\n          break;\n        case 'SSND':\n          chunk.parsed = AIFFSoundDataStruct.parse(chunk.chunkData, 0, {\n            soundDataSize:\n              chunk.ckSize - AIFF_SOUND_DATA_CHUNK_SIZE_EXCL_SOUNDDATA,\n          });\n          output.soundData = chunk.parsed.soundData;\n          break;\n        case 'MARK':\n          chunk.parsed = AIFFMarkerChunkStruct.parse(chunk.chunkData, 0);\n          break;\n        case 'COMT':\n          chunk.parsed = AIFFCommentStruct.parse(chunk.chunkData, 0);\n          break;\n        case 'INST':\n          chunk.parsed = AIFFInstrumentStruct.parse(chunk.chunkData, 0);\n          break;\n        case AIFFNameChunkID:\n        case AIFFAuthorChunkID:\n        case AIFFCopyrightChunkID:\n        case AIFFAnnotationChunkID:\n          chunk.parsed = AIFFTextStruct.parse(chunk.chunkData, 0, {\n            dataSize: chunk.ckSize,\n          });\n          break;\n        case 'APPL':\n          chunk.parsed = AIFCApplicationSpecificStruct.parse(\n            chunk.chunkData,\n            0,\n            {\n              dataSize: chunk.ckSize - AIFC_APPL_CHUNK_SIZE_EXCL_DATA,\n            }\n          );\n          break;\n        case 'FVER':\n          chunk.parsed = AIFCFormatStruct.parse(chunk.chunkData);\n          break;\n        default:\n          DEBUG && console.error('unknown chunk type', chunk.ckID);\n      }\n\n      DEBUG && console.log('local chunk', chunk);\n      parsedFormLocalChunks.push({type: chunk.ckID, data: chunk.parsed});\n\n      localChunks.push(chunk);\n      pos = AIFFChunkStruct.lastOffset;\n    }\n    formChunk.localChunks = localChunks;\n  });\n\n  if (options.includeRawChunks) {\n    output.fileChunks = fileChunks;\n  }\n  output.chunks = parsedFormLocalChunks;\n  return output;\n}\n\nmodule.exports = {\n  serialize: serializeAIFF,\n  parse: parseAIFF,\n  PString,\n  LoopPlayMode,\n};\n","import React from 'react';\n\nexport default function Details({\n  summary,\n  children,\n  style,\n  summaryStyle,\n  startOpen,\n}) {\n  const [open, setOpen] = React.useState(startOpen);\n\n  const onToggle = React.useCallback(\n    (e) => {\n      e.preventDefault();\n      e.stopPropagation();\n      setOpen(!open);\n    },\n    [open]\n  );\n\n  return (\n    <details open={open} style={style}>\n      <summary onClick={onToggle} style={summaryStyle}>\n        {summary}\n      </summary>\n      {open && children}\n    </details>\n  );\n}\n","import { StrictMode } from \"react\";\nimport ReactDOM from \"react-dom\";\n\nimport App from \"./App\";\n\nconst rootElement = document.getElementById(\"root\");\nReactDOM.render(\n  <StrictMode>\n    <App />\n  </StrictMode>,\n  rootElement\n);\n","// https://en.cppreference.com/w/cpp/numeric/math/ldexp\nconst ldexp = (x, exp) => x * Math.pow(2, exp);\n\n// from https://raw.githubusercontent.com/locutusjs/locutus/master/src/c/math/frexp.js\n// license: https://github.com/locutusjs/locutus/blob/master/LICENSE\nfunction frexp(arg) {\n  arg = Number(arg);\n\n  const result = [arg, 0];\n\n  if (arg !== 0 && Number.isFinite(arg)) {\n    const absArg = Math.abs(arg);\n    // Math.log2 was introduced in ES2015, use it when available\n    const log2 =\n      Math.log2 ||\n      function log2(n) {\n        return Math.log(n) * Math.LOG2E;\n      };\n    let exp = Math.max(-1023, Math.floor(log2(absArg)) + 1);\n    let x = absArg * Math.pow(2, -exp);\n\n    // These while loops compensate for rounding errors that sometimes occur because of ECMAScript's Math.log2's undefined precision\n    // and also works around the issue of Math.pow(2, -exp) === Infinity when exp <= -1024\n    while (x < 0.5) {\n      x *= 2;\n      exp--;\n    }\n    while (x >= 1) {\n      x *= 0.5;\n      exp++;\n    }\n\n    if (arg < 0) {\n      x = -x;\n    }\n    result[0] = x;\n    result[1] = exp;\n  }\n  return result;\n}\n\n// this IEEE extended stuff comes from http://groovit.disjunkt.com/analog/specifs/ieee.c\n\n/*\n * C O N V E R T   T O   I E E E   E X T E N D E D\n */\n\nconst FloatToUnsigned = (f) => f - 2147483648.0 + 2147483647 + 1;\n\nfunction ConvertToIeeeExtended(/*double*/ num) {\n  let /*char**/ bytes = new Array(10).fill(0);\n  let /*int*/ sign;\n  let /*int*/ expon;\n  let /*double*/ fMant, fsMant;\n  let /*unsigned long*/ hiMant, loMant;\n\n  if (num < 0) {\n    sign = 0x8000;\n    num *= -1;\n  } else {\n    sign = 0;\n  }\n\n  if (num == 0) {\n    expon = 0;\n    hiMant = 0;\n    loMant = 0;\n  } else {\n    const frexpRes = frexp(num);\n    fMant = frexpRes[0];\n    expon = frexpRes[1];\n\n    if (expon > 16384 || !(fMant < 1)) {\n      /* Infinity or NaN */\n      expon = sign | 0x7fff;\n      hiMant = 0;\n      loMant = 0; /* infinity */\n    } else {\n      /* Finite */\n      expon += 16382;\n      if (expon < 0) {\n        /* denormalized */\n        fMant = ldexp(fMant, expon);\n        expon = 0;\n      }\n      expon |= sign;\n      fMant = ldexp(fMant, 32);\n      fsMant = Math.floor(fMant);\n      hiMant = FloatToUnsigned(fsMant);\n      fMant = ldexp(fMant - fsMant, 32);\n      fsMant = Math.floor(fMant);\n      loMant = FloatToUnsigned(fsMant);\n    }\n  }\n\n  bytes[0] = expon >> 8;\n  bytes[1] = expon;\n  bytes[2] = hiMant >> 24;\n  bytes[3] = hiMant >> 16;\n  bytes[4] = hiMant >> 8;\n  bytes[5] = hiMant;\n  bytes[6] = loMant >> 24;\n  bytes[7] = loMant >> 16;\n  bytes[8] = loMant >> 8;\n  bytes[9] = loMant;\n\n  return bytes;\n}\n\n/*\n * C O N V E R T   F R O M   I E E E   E X T E N D E D\n */\n\nconst UnsignedToFloat = (u) => ((u - 2147483647) | 0) - 1 + 2147483648.0;\n\n/****************************************************************\n * Extended precision IEEE floating-point conversion routine.\n ****************************************************************/\n\nfunction ConvertFromIeeeExtended(/*unsigned char**/ bytes /* LCN */) {\n  let /*double*/ f;\n  let /*int*/ expon;\n  let /*unsigned long*/ hiMant, loMant;\n\n  expon = ((bytes[0] & 0x7f) << 8) | (bytes[1] & 0xff);\n  hiMant =\n    ((bytes[2] & 0xff) << 24) |\n    ((bytes[3] & 0xff) << 16) |\n    ((bytes[4] & 0xff) << 8) |\n    (bytes[5] & 0xff);\n  loMant =\n    ((bytes[6] & 0xff) << 24) |\n    ((bytes[7] & 0xff) << 16) |\n    ((bytes[8] & 0xff) << 8) |\n    (bytes[9] & 0xff);\n\n  if (expon == 0 && hiMant == 0 && loMant == 0) {\n    f = 0;\n  } else {\n    if (expon == 0x7fff) {\n      /* Infinity or NaN */\n      f = Infinity;\n    } else {\n      expon -= 16383;\n      f = ldexp(UnsignedToFloat(hiMant), (expon -= 31));\n      f += ldexp(UnsignedToFloat(loMant), (expon -= 32));\n    }\n  }\n\n  if (bytes[0] & 0x80) return -f;\n  else return f;\n}\n\nmodule.exports = {\n  ConvertFromIeeeExtended,\n  ConvertToIeeeExtended\n};\n","const DEBUG = false;\n\nfunction nullthrows(value, message) {\n  if (value == null) {\n    throw new Error(\"unexpected null\" + (message ? \": \" + message : \"\"));\n  }\n  return value;\n}\n\nfunction nanthrows(value, message) {\n  if (isNaN(value)) {\n    throw new Error(\"unexpected NaN\" + (message ? \": \" + message : \"\"));\n  }\n  return value;\n}\n\nconst FieldTypesToBufferMethods = {\n  uint: \"UInt\",\n  int: \"Int\",\n  float: \"Float\",\n  double: \"Double\",\n  bigint: \"BigInt\",\n  biguint: \"BigUint\",\n  char: \"UInt\"\n};\n\nconst BytesTypes = new Set([\"bytes\", \"utf8\"]);\n\nfunction getBufferMethodName(type, size, endian) {\n  return `${FieldTypesToBufferMethods[type]}${size * 8}${\n    size == 1 ? \"\" : endian == \"big\" ? \"BE\" : \"LE\"\n  }`;\n}\n\nfunction getAlignedSize(size, alignment) {\n  return Math.ceil(size / alignment) * alignment;\n}\n\nfunction getAlignedSizeForField(field, size) {\n  return field.align != null\n    ? getAlignedSize(nanthrows(size), nanthrows(field.align))\n    : nanthrows(size);\n}\n\n/*\n  schema: an object mapping field names to a definition object.\n  definitions can have the following properties: \n  type: how to interpret the binary data. options:\n    uint -> number\n    int -> number\n    float -> number\n    double -> number\n    bigint -> BigInt\n    biguint -> BigInt\n    char -> number\n    bytes -> Buffer\n    utf8 -> string\n    BufferStructBase | BufferStruct | BufferStructUnion -> nested object\n  size: serialized field size in bytes\n  endian: endianness used when interpreting binary data\n  default: default value used when serializing if value not provided\n  size: size of field in bytes. can be fixed size or function determining size\n  arrayElements: treat this field as an array. function returning number of items\n  align: pad the field to a multiple of this number\n */\n\nclass BufferStructBase {\n  constructor(schema) {\n    this.schema = schema;\n    this.lastOffset = 0;\n  }\n\n  parse(buffer, startOffset, contextData = null) {\n    // should return value for this field and update this.lastOffset\n  }\n\n  serialize(data, contextData = null) {\n    // should return buffer of serialized data\n  }\n\n  getStaticSize() {\n    throw new Error(\n      \"getStaticSize not implemented on: \" + this.constructor.name\n    );\n  }\n\n  getName() {\n    return this.schema.name || this.constructor.name;\n  }\n}\n\nclass BufferStruct extends BufferStructBase {\n  parse(buffer, startOffset, contextData = null) {\n    const partialResult = {};\n    let offset = startOffset || 0;\n    Object.keys(this.schema.fields).forEach((fieldName) => {\n      const { field, endian, size, type } = this._getFieldConfig(\n        fieldName,\n        partialResult,\n        contextData\n      );\n\n      const parse = BytesTypes.has(type)\n        ? (buffer, startOffset) => {\n            if (size == null) {\n              throw new Error(\n                `can't parse field of type 'bytes' without predetermined size`\n              );\n            }\n            if (buffer.length < startOffset + size) {\n              throw new Error(\n                `tried to read ${size} bytes but only ${\n                  buffer.length - startOffset\n                } remaining for field ${fieldName} on ${this.getName()}`\n              );\n            }\n            const valueAsBuffer = buffer.slice(startOffset, startOffset + size);\n            let value = valueAsBuffer;\n            if (type === \"utf8\") {\n              value = valueAsBuffer.toString(\"utf8\");\n            }\n            return { value, parsedSize: size };\n          }\n        : type instanceof BufferStructBase\n        ? (buffer, startOffset) => {\n            // console.log('parsing', type.getName(), 'at', startOffset);\n            const value = type.parse(buffer, startOffset, contextData);\n            // use static size where determined (eg. in case of union)\n            const parsedSize =\n              size != null ? size : type.lastOffset - startOffset; // change in offset after parsing\n            // console.log({value, parsedSize});\n\n            return { value, parsedSize };\n          }\n        : (buffer, startOffset) => {\n            const methodName = `read${getBufferMethodName(type, size, endian)}`;\n\n            const value = buffer[methodName](startOffset);\n            if (this.schema.traceReads) {\n              console.log(methodName, {\n                fieldName,\n                type,\n                size,\n                endian,\n                startOffset,\n                value\n              });\n            }\n\n            return { value, parsedSize: size };\n          };\n\n      // the ability to provide predetermined size, as well as define alignment, means we need to account for either of these\n      // sources of padding when advancing the point we are reading in the buffer\n      const parseWithAlignment = (buffer, startOffset) => {\n        const { value, parsedSize } = parse(buffer, nanthrows(startOffset));\n\n        if (size != null && parsedSize > size) {\n          throw new Error(\n            `parsed size ${parsedSize} larger than predetermined size ${size} for field ${fieldName} on ${this.getName()}`\n          );\n        }\n\n        // when field is aligned we must make sure to advance by aligned size\n        // additionally, if a predetermined size is set, we should use that size instead (in case of padding)\n        // we have already asserted above that the parsed size is not larger than the predetermined size\n        let parsedSizeWithAlignment = getAlignedSizeForField(\n          field,\n          size != null ? size : parsedSize\n        );\n\n        if (size != null) {\n          const alignedExpectedSize = getAlignedSizeForField(field, size);\n\n          if (parsedSizeWithAlignment > alignedExpectedSize) {\n            throw new Error(\n              `aligned parsed size ${parsedSizeWithAlignment} larger than aligned predetermined size ${alignedExpectedSize} for field ${fieldName} on ${this.getName()}`\n            );\n          }\n        }\n\n        return { value, consumedSize: nanthrows(parsedSizeWithAlignment) };\n      };\n\n      // try {\n      if (field.arrayElements) {\n        // array field\n        const count =\n          typeof field.arrayElements === \"function\"\n            ? field.arrayElements(partialResult, contextData)\n            : field.arrayElements;\n        const array = new Array(count);\n\n        for (var i = 0; i < count; ++i) {\n          // console.log('getting array el', i, 'of', count, 'at', offset);\n          const { value, consumedSize } = parseWithAlignment(buffer, offset);\n\n          offset += nanthrows(consumedSize);\n          array[i] = value;\n        }\n\n        partialResult[fieldName] = array;\n      } else {\n        // non-array field\n        const { value, consumedSize } = parseWithAlignment(buffer, offset);\n        offset += nanthrows(consumedSize);\n        partialResult[fieldName] = value;\n      }\n      // } catch (error) {\n      //   throw new Error(\n      //     `failed parsing field ${fieldName} on ${this.getName()}: ${error}`\n      //   );\n      // }\n    });\n    if (isNaN(offset)) {\n      throw new Error(`invalid offset while parsing ${this.getName()}`);\n    }\n    this.lastOffset = offset;\n    return partialResult;\n  }\n\n  _getFieldConfig(fieldName, partialFieldData, contextData) {\n    const field = nullthrows(\n      this.schema.fields[fieldName],\n      `${fieldName} schema is missing`\n    );\n    const endian = field.endian || this.schema.endian || \"little\";\n    const type = nullthrows(field.type, `${fieldName} type`);\n    if (\n      !(\n        type instanceof BufferStructBase ||\n        type instanceof BufferStructUnion ||\n        type in FieldTypesToBufferMethods ||\n        BytesTypes.has(type)\n      )\n    ) {\n      throw new Error(`unsupported type ${type} in ${fieldName}`);\n    }\n\n    // use statically defined size if we've got it\n    let size =\n      typeof field.size === \"function\"\n        ? field.size(partialFieldData, contextData)\n        : field.size;\n    if (BytesTypes.has(type)) {\n      // allow size to be dynamic\n    } else if (type instanceof BufferStructBase) {\n      // allow size to be dynamic\n    } else if (type instanceof BufferStructUnion) {\n      // size will be statically known (asserted in BufferStructUnion)\n      size = type.size;\n    } else {\n      // size must be statically known\n      size = nullthrows(size, `${fieldName} size`);\n    }\n\n    let actualType = type;\n    // replace union type with actual type\n    if (type instanceof BufferStructUnion) {\n      actualType = type.selectMember(partialFieldData, contextData);\n      if (actualType == null) {\n        throw new Error(\n          `failed to refine union type in field ${fieldName} on ${this.getName()}`\n        );\n      }\n    }\n\n    return { field, endian, size, type: actualType };\n  }\n\n  serialize(data, contextData = null) {\n    if (!data) {\n      throw new Error(\n        `missing argument 'data' when serializing ${this.getName()}`\n      );\n    }\n    const parts = [];\n    Object.keys(this.schema.fields).forEach((fieldName) => {\n      const { field, endian, size, type } = this._getFieldConfig(\n        fieldName,\n        data,\n        contextData\n      );\n\n      let value;\n      if (!(fieldName in data)) {\n        if (\"default\" in field) {\n          value = field.default;\n        } else {\n          throw new Error(\n            `missing field ${fieldName} when serializing ${this.getName()}`\n          );\n        }\n      }\n      value = data[fieldName];\n\n      const serialize = BytesTypes.has(type)\n        ? (value) => {\n            let valueAsBuffer = value;\n            if (type === \"utf8\") {\n              valueAsBuffer = Buffer.from(value, \"utf8\");\n            }\n\n            const dynSize = size == null ? valueAsBuffer.length : size;\n            const partBuffer = Buffer.alloc(dynSize);\n            valueAsBuffer.copy(partBuffer, 0, 0, dynSize);\n\n            return partBuffer;\n          }\n        : type instanceof BufferStructBase\n        ? (value) => type.serialize(value, contextData)\n        : (value) => {\n            const methodName = `write${getBufferMethodName(\n              type,\n              size,\n              endian\n            )}`;\n\n            const partBuffer = Buffer.alloc(size);\n            partBuffer[methodName](value);\n            if (this.schema.traceWrites) {\n              console.log(methodName, {\n                fieldName,\n                type,\n                size,\n                endian,\n                value\n              });\n            }\n\n            return partBuffer;\n          };\n\n      const serializeWithAlignment = (value) => {\n        const partBuffer = serialize(value);\n        const serializedSize = partBuffer.length;\n        if (size != null && serializedSize > size) {\n          throw new Error(\n            `serialized size ${serializedSize} larger than predetermined size ${size} for field ${fieldName} on ${this.getName()}`\n          );\n        }\n\n        let maybeAlignedPartBuffer = partBuffer;\n        if (field.align != null) {\n          const alignedSerializedSize = getAlignedSize(\n            serializedSize,\n            field.align\n          );\n          const alignedExpectedSize = getAlignedSize(size, field.align);\n          if (alignedSerializedSize > alignedExpectedSize)\n            throw new Error(\n              `serialized aligned size ${\n                maybeAlignedPartBuffer.length\n              } larger than predetermined size (aligned) ${alignedExpectedSize} for field ${fieldName} on ${this.getName()}`\n            );\n\n          const partBufferAligned = Buffer.alloc(alignedSerializedSize);\n          partBuffer.copy(partBufferAligned);\n          maybeAlignedPartBuffer = partBufferAligned;\n        }\n\n        return maybeAlignedPartBuffer;\n      };\n\n      // try {\n      if (field.arrayElements) {\n        for (var i = 0; i < value.length; ++i) {\n          const part = serializeWithAlignment(value[i]);\n          parts.push(part);\n        }\n      } else {\n        const part = serializeWithAlignment(value);\n        parts.push(part);\n      }\n      // } catch (error) {\n      //   const extra = DEBUG ? `${error.stack} \\nrethrown stack:` : '';\n      //   throw new Error(\n      //     `failed serializing field ${fieldName}: ${error} ${extra}`\n      //   );\n      // }\n    });\n\n    return Buffer.concat(parts);\n  }\n\n  _staticSize = null;\n  getStaticSize() {\n    const prevSize = this._staticSize;\n    if (prevSize != null) {\n      return prevSize;\n    } else {\n      let size = 0;\n      for (const field of Object.values(this.schema.fields)) {\n        if (typeof field.size != \"number\") {\n          throw new Error(\n            \"cannot get static size of struct: \" + this.getName()\n          );\n        }\n        const alignedFieldSize = getAlignedSizeForField(field, field.size);\n        size += alignedFieldSize;\n      }\n      this._staticSize = size;\n      return size;\n    }\n  }\n}\n\n// simulates c struct union functionality, using the provided selectMember function\n// to choose which union member (BufferStruct) to interpret data as based on previously parsed fields.\n// requires that all union members have statically determinable size (eg. no arrays or dynamically sized bytes fields allowed)\n// when serializing, the maximum member size will be used\nclass BufferStructUnion {\n  constructor({ members, selectMember }) {\n    this.selectMember = selectMember;\n    this.members = members;\n    this.size = Math.max(...members.map((m) => m.getStaticSize()));\n  }\n}\n\nmodule.exports = {\n  BufferStruct,\n  BufferStructBase,\n  BufferStructUnion\n};\n"],"sourceRoot":""}