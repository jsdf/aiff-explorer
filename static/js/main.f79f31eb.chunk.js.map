{"version":3,"sources":["aiff.js","index.js","ieeeextended.js","bufferstruct.js","App.js"],"names":["ieeeExtended","require","BufferStruct","BufferStructBase","BufferStructUnion","PString","constructor","super","name","parse","buffer","startOffset","contextData","length","readUInt8","str","slice","toString","consumed","size","alignment","Math","ceil","this","lastOffset","serialize","data","Error","getName","parts","Buffer","from","push","alloc","concat","AIFFChunkStruct","endian","fields","ckID","type","ckSize","chunkData","align","AIFFCommonStruct","numChannels","numSampleFrames","sampleSize","sampleRate","AIFCCommonStruct","compressionType","compressionName","AIFCApplicationSpecificStruct","applicationSignature","context","dataSize","AIFFSoundDataStruct","offset","blockSize","soundData","soundDataSize","AIFFMarkerIdField","AIFFMarkerStruct","id","position","markerName","AIFFCommentStruct","timeStamp","marker","count","text","AIFFLoopStruct","playMode","beginLoop","endLoop","AIFFInstrumentStruct","baseNote","detune","lowNote","highNote","lowVelocity","highVelocity","gain","sustainLoop","releaseLoop","AIFFTextStruct","_","AIFCFormatStruct","timestamp","makeAIFFChunk","module","exports","form","appl","nsamples","floor","sampleRate80Bit","ConvertToIeeeExtended","console","log","formatChunk","commChunk","soundDataChunk","applChunks","map","applObj","formType","filter","Boolean","fileContents","pos","output","fileChunks","error","chunk","endOffset","formChunks","fileChunk","forEach","formChunk","formID","localChunks","comm","ConvertFromIeeeExtended","ssnd","mark","comt","inst","toLowerCase","format","fver","rootElement","document","getElementById","ReactDOM","render","ldexp","x","exp","pow","FloatToUnsigned","f","UnsignedToFloat","u","bytes","expon","hiMant","loMant","Infinity","num","sign","fMant","fsMant","Array","fill","frexpRes","arg","result","Number","isFinite","absArg","abs","log2","n","LOG2E","max","frexp","nullthrows","value","message","nanthrows","isNaN","FieldTypesToBufferMethods","uint","int","float","double","bigint","biguint","char","BytesTypes","Set","getBufferMethodName","getAlignedSize","getAlignedSizeForField","field","schema","getStaticSize","members","selectMember","m","_staticSize","partialResult","Object","keys","fieldName","_getFieldConfig","has","valueAsBuffer","parsedSize","methodName","traceReads","parseWithAlignment","parsedSizeWithAlignment","alignedExpectedSize","consumedSize","arrayElements","array","i","partialFieldData","actualType","default","dynSize","partBuffer","copy","traceWrites","serializeWithAlignment","serializedSize","maybeAlignedPartBuffer","alignedSerializedSize","partBufferAligned","part","prevSize","values","readFile","file","Promise","resolve","reject","reader","FileReader","readAsArrayBuffer","addEventListener","boxStyle","border","textStyle","margin","wordWrap","DisplayObject","object","style","key","JSON","stringify","AiffChunk","chunkSpecificData","lchunk","fontSize","color","App","useState","aiff","setAiff","setError","handleFiles","useCallback","e","a","fileList","currentTarget","files","AIFF","err","className","onChange","stack"],"mappings":"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","file":"static/js/main.f79f31eb.chunk.js","sourcesContent":["const ieeeExtended = require(\"./ieeeextended\");\nconst {\n  BufferStruct,\n  BufferStructUnion,\n  BufferStructBase\n} = require(\"./bufferstruct\");\n\nconst DEBUG = true;\n\nfunction getAlignedSize(size, alignment) {\n  return Math.ceil(size / alignment) * alignment;\n}\n\n// pascal-style string\nclass PStringParser extends BufferStructBase {\n  constructor() {\n    super({ name: \"PString\" });\n  }\n  parse(buffer, startOffset, contextData = null) {\n    const length = buffer.readUInt8(startOffset);\n\n    const str = buffer\n      .slice(startOffset + 1, startOffset + 1 + length)\n      .toString(\"utf8\");\n\n    const consumed = getAlignedSize(1 + length, 2); // pad to multiple of 2\n\n    this.lastOffset = startOffset + consumed;\n    return str;\n  }\n\n  serialize(data, contextData = null) {\n    if (!data) {\n      throw new Error(\n        `missing argument 'data' when serializing ${this.getName()}`\n      );\n    }\n\n    const parts = [Buffer.from([data.length]), Buffer.from(data)];\n\n    // pad to even size\n    if ((1 + data.length) % 2 === 1) {\n      parts.push(Buffer.alloc(1));\n    }\n\n    return Buffer.concat(parts);\n  }\n}\n\nconst PString = new PStringParser();\n\n// AIFF stuff\n// http://paulbourke.net/dataformats/audio/\n// http://www-mmsp.ece.mcgill.ca/Documents/AudioFormats/AIFF/Docs/AIFF-1.3.pdf\n// http://www-mmsp.ece.mcgill.ca/Documents/AudioFormats/AIFF/Docs/AIFF-C.9.26.91.pdf\nconst AIFFChunkStruct = new BufferStruct({\n  name: \"AIFFChunk\",\n  endian: \"big\",\n  fields: {\n    ckID: { type: \"utf8\", size: 4 },\n    ckSize: { type: \"int\", size: 4 },\n    chunkData: { type: \"bytes\", align: 2, size: (fields) => fields.ckSize }\n  }\n});\n\n// short numChannels;\n// unsigned long numSampleFrames;\n// short sampleSize;\n// extended sampleRate;\nconst AIFFCommonStruct = new BufferStruct({\n  name: \"AIFFCommon\",\n  endian: \"big\",\n  fields: {\n    numChannels: { type: \"int\", size: 2 },\n    numSampleFrames: { type: \"uint\", size: 4 },\n    sampleSize: { type: \"int\", size: 2 },\n    sampleRate: { type: \"bytes\", size: 10 }\n  }\n});\n\n// short numChannels; /* # audio channels */\n// unsigned long numSampleFrames; /* # sample frames = samples/channel */\n// short sampleSize; /* # bits/sample */\n// extended sampleRate; /* sample_frames/sec */\n// ID compressionType; /* compression type ID code */\n// pstring compressionName; /* human-readable compression type name */\nconst AIFCCommonStruct = new BufferStruct({\n  name: \"AIFCCommon\",\n  endian: \"big\",\n  fields: {\n    numChannels: { type: \"int\", size: 2 },\n    numSampleFrames: { type: \"uint\", size: 4 },\n    sampleSize: { type: \"int\", size: 2 },\n    sampleRate: { type: \"bytes\", size: 10 },\n    compressionType: { type: \"utf8\", size: 4 },\n    compressionName: { type: PString }\n  }\n});\n\n// #define ApplicationSpecificID 'APPL' /* ckID for Application Specific Chunk */\n// typedef struct {\n// ID ckID; /* 'APPL' */\n// long ckDataSize;\n// OSType applicationSignature;\n// char data[];\n// } ApplicationSpecificChunk;\nconst AIFC_APPL_CHUNK_SIZE_EXCL_DATA = 4; // sum of fixed-size fields\nconst AIFCApplicationSpecificStruct = new BufferStruct({\n  name: \"AIFCApplicationSpecific\",\n  endian: \"big\",\n  fields: {\n    applicationSignature: { type: \"utf8\", size: 4 },\n    data: {\n      type: \"bytes\",\n      size: (fields, context) => context.dataSize\n    }\n  }\n});\n\n// unsigned long offset;\n// unsigned long blockSize;\nconst AIFF_SOUND_DATA_CHUNK_SIZE_EXCL_SOUNDDATA = 8; // sum of fixed-size fields\nconst AIFFSoundDataStruct = new BufferStruct({\n  name: \"AIFFSoundData\",\n  endian: \"big\",\n  fields: {\n    offset: { type: \"uint\", size: 4 },\n    blockSize: { type: \"uint\", size: 4 },\n    soundData: {\n      type: \"bytes\",\n      size: (fields, context) => context.soundDataSize\n    }\n  }\n});\n\n// typedef short MarkerId;\nconst AIFFMarkerIdField = { type: \"int\", size: 2 };\n//   typedef struct {\n//   MarkerId id; /* must be > 0 */\n//   unsigned long position; /* sample frame number */\n//   pstring markerName;\n// } Marker;\nconst AIFFMarkerStruct = new BufferStruct({\n  name: \"AIFFMarker\",\n  endian: \"big\",\n  fields: {\n    id: AIFFMarkerIdField,\n    position: { type: \"uint\", size: 4 },\n    markerName: { type: PString }\n  }\n});\n\n// typedef struct {\n//   unsigned long timeStamp; /* comment creation date */\n//   MarkerId marker; /* comments for this marker number */\n//   unsigned short count; /* comment text string length */\n//   char text[]; /* comment text */\n// } Comment;\nconst AIFFCommentStruct = new BufferStruct({\n  name: \"AIFFComment\",\n  endian: \"big\",\n  fields: {\n    timeStamp: { type: \"uint\", size: 4 },\n    marker: AIFFMarkerIdField,\n    count: { type: \"uint\", size: 2 },\n    text: { type: \"utf8\", size: (fields) => fields.count }\n  }\n});\n\nconst AIFFPlayModeNoLooping = 0;\nconst AIFFPlayModeForwardLooping = 1;\nconst AIFFPlayModeForwardBackwardLooping = 2;\n\n// typedef struct {\n//   short playMode;\n//   MarkerId beginLoop;\n//   MarkerId endLoop;\n// } Loop;\nconst AIFFLoopStruct = new BufferStruct({\n  name: \"AIFFLoop\",\n  endian: \"big\",\n  fields: {\n    playMode: { type: \"int\", size: 2 },\n    beginLoop: AIFFMarkerIdField,\n    endLoop: AIFFMarkerIdField\n  }\n});\n\n// typedef struct {\n//   char baseNote;\n//   char detune;\n//   char lowNote;\n//   char highNote;\n//   char lowVelocity;\n//   char highVelocity;\n//   short gain;\n//   Loop sustainLoop;\n//   Loop releaseLoop;\n// } InstrumentChunk;\nconst AIFFInstrumentStruct = new BufferStruct({\n  name: \"AIFFInstrument\",\n  endian: \"big\",\n  fields: {\n    baseNote: { type: \"int\", size: 1 },\n    detune: { type: \"int\", size: 1 },\n    lowNote: { type: \"int\", size: 1 },\n    highNote: { type: \"int\", size: 1 },\n    lowVelocity: { type: \"int\", size: 1 },\n    highVelocity: { type: \"int\", size: 1 },\n    gain: { type: \"int\", size: 2 },\n    sustainLoop: { type: AIFFLoopStruct },\n    releaseLoop: { type: AIFFLoopStruct }\n  }\n});\nconst AIFFNameChunkID = \"NAME\"; /* ckID for Name Chunk */\nconst AIFFAuthorChunkID = \"AUTH\"; /* ckID for Author Chunk */\nconst AIFFCopyrightChunkID = \"(c) \"; /* ckID for Copyright Chunk */\nconst AIFFAnnotationChunkID = \"ANNO\"; /* ckID for Annotation Chunk */\n// typedef struct {\n//   ID ckID;\n//   long ckDataSize;\n//   char text[];\n// } TextChunk;\nconst AIFFTextStruct = new BufferStruct({\n  name: \"AIFFText\",\n  endian: \"big\",\n  fields: {\n    text: { type: \"utf8\", size: (_, context) => context.dataSize }\n  }\n});\n\nconst AIFCVersion1 = 0xa2805140; /* Version 1 of AIFF-C */\n\nconst AIFCFormatStruct = new BufferStruct({\n  name: \"AIFCFormat\",\n  endian: \"big\",\n  fields: {\n    timestamp: { type: \"uint\", size: 4 }\n  }\n});\n\nfunction makeAIFFChunk(ckID, chunkData) {\n  return AIFFChunkStruct.serialize({\n    ckID,\n    ckSize: chunkData.length,\n    chunkData\n  });\n}\n\nfunction serializeAIFF({\n  soundData,\n  numChannels,\n  sampleRate,\n  sampleSize,\n  form,\n  compressionType,\n  compressionName,\n  appl\n}) {\n  const nsamples = Math.floor(\n    soundData.length / numChannels / (sampleSize / 8)\n  );\n  const sampleRate80Bit = Buffer.from(\n    ieeeExtended.ConvertToIeeeExtended(sampleRate)\n  );\n  DEBUG && console.log({ sampleRate, sampleRate80Bit });\n\n  const formatChunk =\n    form === \"AIFC\"\n      ? makeAIFFChunk(\n          \"FVER\",\n          AIFCFormatStruct.serialize({\n            timestamp: AIFCVersion1\n          })\n        )\n      : null;\n\n  const commChunk = makeAIFFChunk(\n    \"COMM\",\n    form === \"AIFC\"\n      ? AIFCCommonStruct.serialize({\n          numChannels,\n          numSampleFrames: nsamples,\n          sampleSize,\n          sampleRate: sampleRate80Bit,\n          compressionType,\n          compressionName\n        })\n      : AIFFCommonStruct.serialize({\n          numChannels,\n          numSampleFrames: nsamples,\n          sampleSize,\n          sampleRate: sampleRate80Bit\n        })\n  );\n\n  const soundDataChunk = makeAIFFChunk(\n    \"SSND\",\n    Buffer.concat([\n      AIFFSoundDataStruct.serialize(\n        {\n          offset: 0,\n          blockSize: 0,\n          soundData\n        },\n        {\n          soundDataSize: soundData.length\n        }\n      )\n    ])\n  );\n\n  const applChunks =\n    form === \"AIFC\" && appl\n      ? appl.map((applObj) =>\n          makeAIFFChunk(\n            \"APPL\",\n            Buffer.concat([\n              AIFCApplicationSpecificStruct.serialize(applObj, {\n                dataSize: applObj.data.length\n              })\n            ])\n          )\n        )\n      : [];\n\n  const formType = Buffer.from(form === \"AIFC\" ? \"AIFC\" : \"AIFF\", \"utf8\");\n\n  const aiffFileContents = makeAIFFChunk(\n    \"FORM\",\n    Buffer.concat(\n      [formType, formatChunk, commChunk, soundDataChunk, ...applChunks].filter(\n        Boolean\n      )\n    )\n  );\n\n  return aiffFileContents;\n}\n\nfunction parseAIFF(fileContents) {\n  let pos = 0;\n\n  let output = {};\n\n  const fileChunks = [];\n  while (pos < fileContents.length) {\n    DEBUG &&\n      console.error(\n        \"parsing file chunk\",\n        fileContents.slice(pos, pos + 4).toString(\"utf8\"),\n        \"at\",\n        pos,\n        { fileContents }\n      );\n    const chunk = AIFFChunkStruct.parse(fileContents, pos);\n    chunk.startOffset = pos;\n    chunk.endOffset = AIFFChunkStruct.lastOffset;\n    fileChunks.push(chunk);\n    pos = AIFFChunkStruct.lastOffset;\n  }\n\n  DEBUG && console.log(fileChunks);\n\n  const formChunks = fileChunks.filter(\n    (fileChunk) => fileChunk.ckID === \"FORM\"\n  );\n  formChunks.forEach((formChunk) => {\n    let pos = 0;\n    DEBUG && console.log(\"FORM chunk\", formChunk);\n    formChunk.form = formChunk.chunkData.slice(0, 4).toString(\"utf8\");\n    output.form = formChunk.form;\n    pos += 4; // skip FORM identifier\n    DEBUG && console.log({ formID: formChunk.form });\n\n    const localChunks = [];\n    while (pos < formChunk.chunkData.length) {\n      DEBUG &&\n        console.error(\n          \"parsing FORM local chunk\",\n          formChunk.chunkData.slice(pos, pos + 4),\n          \"at\",\n          pos\n        );\n      const chunk = AIFFChunkStruct.parse(formChunk.chunkData, pos);\n      chunk.startOffset = pos;\n      chunk.endOffset = AIFFChunkStruct.lastOffset;\n\n      if (chunk.ckSize === 0) {\n        DEBUG &&\n          console.error(\n            \"zero size chunk\",\n            formChunk.chunkData.slice(pos, pos + 64)\n          );\n      }\n      switch (chunk.ckID) {\n        case \"COMM\":\n          chunk.comm =\n            formChunk.form === \"AIFC\"\n              ? AIFCCommonStruct.parse(chunk.chunkData)\n              : AIFFCommonStruct.parse(chunk.chunkData);\n          chunk.comm.sampleRate = ieeeExtended.ConvertFromIeeeExtended(\n            chunk.comm.sampleRate\n          );\n\n          output.sampleRate = chunk.comm.sampleRate;\n          output.sampleSize = chunk.comm.sampleSize;\n          output.numChannels = chunk.comm.numChannels;\n          output.compressionType = chunk.comm.compressionType;\n          output.compressionName = chunk.comm.compressionName;\n          break;\n        case \"SSND\":\n          chunk.ssnd = AIFFSoundDataStruct.parse(chunk.chunkData, 0, {\n            soundDataSize:\n              chunk.ckSize - AIFF_SOUND_DATA_CHUNK_SIZE_EXCL_SOUNDDATA\n          });\n          output.soundData = chunk.ssnd.soundData;\n          break;\n        case \"MARK\":\n          chunk.mark = AIFFMarkerStruct.parse(chunk.chunkData, 0);\n          break;\n        case \"COMT\":\n          chunk.comt = AIFFCommentStruct.parse(chunk.chunkData, 0);\n          break;\n        case \"INST\":\n          chunk.inst = AIFFInstrumentStruct.parse(chunk.chunkData, 0);\n          break;\n        case AIFFNameChunkID:\n        case AIFFAuthorChunkID:\n        case AIFFCopyrightChunkID:\n        case AIFFAnnotationChunkID:\n          chunk[chunk.ckID.toLowerCase()] = AIFFTextStruct.parse(\n            chunk.chunkData,\n            0,\n            {\n              dataSize: chunk.ckSize\n            }\n          );\n          break;\n        case \"APPL\":\n          chunk.appl = AIFCApplicationSpecificStruct.parse(chunk.chunkData, 0, {\n            dataSize: chunk.ckSize - AIFC_APPL_CHUNK_SIZE_EXCL_DATA\n          });\n          output.appl = output.appl || [];\n          output.appl.push(chunk.appl);\n          break;\n        case \"AIFC\":\n          chunk.format = AIFCFormatStruct.parse(chunk.chunkData);\n          break;\n        case \"FVER\":\n          chunk.fver = AIFCFormatStruct.parse(chunk.chunkData);\n          break;\n        default:\n          DEBUG && console.error(\"unknown chunk type\", chunk.ckID);\n      }\n\n      DEBUG && console.log(\"local chunk\", chunk);\n\n      localChunks.push(chunk);\n      pos = AIFFChunkStruct.lastOffset;\n    }\n    formChunk.localChunks = localChunks;\n  });\n  output.fileChunks = fileChunks;\n  output.formChunks = formChunks;\n  return output;\n}\n\nmodule.exports = {\n  serialize: serializeAIFF,\n  parse: parseAIFF,\n  PString\n};\n","import { StrictMode } from \"react\";\nimport ReactDOM from \"react-dom\";\n\nimport App from \"./App\";\n\nconst rootElement = document.getElementById(\"root\");\nReactDOM.render(\n  <StrictMode>\n    <App />\n  </StrictMode>,\n  rootElement\n);\n","// https://en.cppreference.com/w/cpp/numeric/math/ldexp\nconst ldexp = (x, exp) => x * Math.pow(2, exp);\n\n// from https://raw.githubusercontent.com/locutusjs/locutus/master/src/c/math/frexp.js\n// license: https://github.com/locutusjs/locutus/blob/master/LICENSE\nfunction frexp(arg) {\n  arg = Number(arg);\n\n  const result = [arg, 0];\n\n  if (arg !== 0 && Number.isFinite(arg)) {\n    const absArg = Math.abs(arg);\n    // Math.log2 was introduced in ES2015, use it when available\n    const log2 =\n      Math.log2 ||\n      function log2(n) {\n        return Math.log(n) * Math.LOG2E;\n      };\n    let exp = Math.max(-1023, Math.floor(log2(absArg)) + 1);\n    let x = absArg * Math.pow(2, -exp);\n\n    // These while loops compensate for rounding errors that sometimes occur because of ECMAScript's Math.log2's undefined precision\n    // and also works around the issue of Math.pow(2, -exp) === Infinity when exp <= -1024\n    while (x < 0.5) {\n      x *= 2;\n      exp--;\n    }\n    while (x >= 1) {\n      x *= 0.5;\n      exp++;\n    }\n\n    if (arg < 0) {\n      x = -x;\n    }\n    result[0] = x;\n    result[1] = exp;\n  }\n  return result;\n}\n\n// this IEEE extended stuff comes from http://groovit.disjunkt.com/analog/specifs/ieee.c\n\n/*\n * C O N V E R T   T O   I E E E   E X T E N D E D\n */\n\nconst FloatToUnsigned = (f) => f - 2147483648.0 + 2147483647 + 1;\n\nfunction ConvertToIeeeExtended(/*double*/ num) {\n  let /*char**/ bytes = new Array(10).fill(0);\n  let /*int*/ sign;\n  let /*int*/ expon;\n  let /*double*/ fMant, fsMant;\n  let /*unsigned long*/ hiMant, loMant;\n\n  if (num < 0) {\n    sign = 0x8000;\n    num *= -1;\n  } else {\n    sign = 0;\n  }\n\n  if (num == 0) {\n    expon = 0;\n    hiMant = 0;\n    loMant = 0;\n  } else {\n    const frexpRes = frexp(num);\n    fMant = frexpRes[0];\n    expon = frexpRes[1];\n\n    if (expon > 16384 || !(fMant < 1)) {\n      /* Infinity or NaN */\n      expon = sign | 0x7fff;\n      hiMant = 0;\n      loMant = 0; /* infinity */\n    } else {\n      /* Finite */\n      expon += 16382;\n      if (expon < 0) {\n        /* denormalized */\n        fMant = ldexp(fMant, expon);\n        expon = 0;\n      }\n      expon |= sign;\n      fMant = ldexp(fMant, 32);\n      fsMant = Math.floor(fMant);\n      hiMant = FloatToUnsigned(fsMant);\n      fMant = ldexp(fMant - fsMant, 32);\n      fsMant = Math.floor(fMant);\n      loMant = FloatToUnsigned(fsMant);\n    }\n  }\n\n  bytes[0] = expon >> 8;\n  bytes[1] = expon;\n  bytes[2] = hiMant >> 24;\n  bytes[3] = hiMant >> 16;\n  bytes[4] = hiMant >> 8;\n  bytes[5] = hiMant;\n  bytes[6] = loMant >> 24;\n  bytes[7] = loMant >> 16;\n  bytes[8] = loMant >> 8;\n  bytes[9] = loMant;\n\n  return bytes;\n}\n\n/*\n * C O N V E R T   F R O M   I E E E   E X T E N D E D\n */\n\nconst UnsignedToFloat = (u) => ((u - 2147483647) | 0) - 1 + 2147483648.0;\n\n/****************************************************************\n * Extended precision IEEE floating-point conversion routine.\n ****************************************************************/\n\nfunction ConvertFromIeeeExtended(/*unsigned char**/ bytes /* LCN */) {\n  let /*double*/ f;\n  let /*int*/ expon;\n  let /*unsigned long*/ hiMant, loMant;\n\n  expon = ((bytes[0] & 0x7f) << 8) | (bytes[1] & 0xff);\n  hiMant =\n    ((bytes[2] & 0xff) << 24) |\n    ((bytes[3] & 0xff) << 16) |\n    ((bytes[4] & 0xff) << 8) |\n    (bytes[5] & 0xff);\n  loMant =\n    ((bytes[6] & 0xff) << 24) |\n    ((bytes[7] & 0xff) << 16) |\n    ((bytes[8] & 0xff) << 8) |\n    (bytes[9] & 0xff);\n\n  if (expon == 0 && hiMant == 0 && loMant == 0) {\n    f = 0;\n  } else {\n    if (expon == 0x7fff) {\n      /* Infinity or NaN */\n      f = Infinity;\n    } else {\n      expon -= 16383;\n      f = ldexp(UnsignedToFloat(hiMant), (expon -= 31));\n      f += ldexp(UnsignedToFloat(loMant), (expon -= 32));\n    }\n  }\n\n  if (bytes[0] & 0x80) return -f;\n  else return f;\n}\n\nmodule.exports = {\n  ConvertFromIeeeExtended,\n  ConvertToIeeeExtended\n};\n","const DEBUG = false;\n\nfunction nullthrows(value, message) {\n  if (value == null) {\n    throw new Error(\"unexpected null\" + (message ? \": \" + message : \"\"));\n  }\n  return value;\n}\n\nfunction nanthrows(value, message) {\n  if (isNaN(value)) {\n    throw new Error(\"unexpected NaN\" + (message ? \": \" + message : \"\"));\n  }\n  return value;\n}\n\nconst FieldTypesToBufferMethods = {\n  uint: \"UInt\",\n  int: \"Int\",\n  float: \"Float\",\n  double: \"Double\",\n  bigint: \"BigInt\",\n  biguint: \"BigUint\",\n  char: \"UInt\"\n};\n\nconst BytesTypes = new Set([\"bytes\", \"utf8\"]);\n\nfunction getBufferMethodName(type, size, endian) {\n  return `${FieldTypesToBufferMethods[type]}${size * 8}${\n    size == 1 ? \"\" : endian == \"big\" ? \"BE\" : \"LE\"\n  }`;\n}\n\nfunction getAlignedSize(size, alignment) {\n  return Math.ceil(size / alignment) * alignment;\n}\n\nfunction getAlignedSizeForField(field, size) {\n  return field.align != null\n    ? getAlignedSize(nanthrows(size), nanthrows(field.align))\n    : nanthrows(size);\n}\n\n/*\n  schema: an object mapping field names to a definition object.\n  definitions can have the following properties: \n  type: how to interpret the binary data. options:\n    uint -> number\n    int -> number\n    float -> number\n    double -> number\n    bigint -> BigInt\n    biguint -> BigInt\n    char -> number\n    bytes -> Buffer\n    utf8 -> string\n    BufferStructBase | BufferStruct | BufferStructUnion -> nested object\n  size: serialized field size in bytes\n  endian: endianness used when interpreting binary data\n  default: default value used when serializing if value not provided\n  size: size of field in bytes. can be fixed size or function determining size\n  arrayElements: treat this field as an array. function returning number of items\n  align: pad the field to a multiple of this number\n */\n\nclass BufferStructBase {\n  constructor(schema) {\n    this.schema = schema;\n    this.lastOffset = 0;\n  }\n\n  parse(buffer, startOffset, contextData = null) {\n    // should return value for this field and update this.lastOffset\n  }\n\n  serialize(data, contextData = null) {\n    // should return buffer of serialized data\n  }\n\n  getStaticSize() {\n    throw new Error(\n      \"getStaticSize not implemented on: \" + this.constructor.name\n    );\n  }\n\n  getName() {\n    return this.schema.name || this.constructor.name;\n  }\n}\n\nclass BufferStruct extends BufferStructBase {\n  parse(buffer, startOffset, contextData = null) {\n    const partialResult = {};\n    let offset = startOffset || 0;\n    Object.keys(this.schema.fields).forEach((fieldName) => {\n      const { field, endian, size, type } = this._getFieldConfig(\n        fieldName,\n        partialResult,\n        contextData\n      );\n\n      const parse = BytesTypes.has(type)\n        ? (buffer, startOffset) => {\n            if (size == null) {\n              throw new Error(\n                `can't parse field of type 'bytes' without predetermined size`\n              );\n            }\n            if (buffer.length < startOffset + size) {\n              throw new Error(\n                `tried to read ${size} bytes but only ${\n                  buffer.length - startOffset\n                } remaining for field ${fieldName} on ${this.getName()}`\n              );\n            }\n            const valueAsBuffer = buffer.slice(startOffset, startOffset + size);\n            let value = valueAsBuffer;\n            if (type === \"utf8\") {\n              value = valueAsBuffer.toString(\"utf8\");\n            }\n            return { value, parsedSize: size };\n          }\n        : type instanceof BufferStructBase\n        ? (buffer, startOffset) => {\n            // console.log('parsing', type.getName(), 'at', startOffset);\n            const value = type.parse(buffer, startOffset, contextData);\n            // use static size where determined (eg. in case of union)\n            const parsedSize =\n              size != null ? size : type.lastOffset - startOffset; // change in offset after parsing\n            // console.log({value, parsedSize});\n\n            return { value, parsedSize };\n          }\n        : (buffer, startOffset) => {\n            const methodName = `read${getBufferMethodName(type, size, endian)}`;\n\n            const value = buffer[methodName](startOffset);\n            if (this.schema.traceReads) {\n              console.log(methodName, {\n                fieldName,\n                type,\n                size,\n                endian,\n                startOffset,\n                value\n              });\n            }\n\n            return { value, parsedSize: size };\n          };\n\n      // the ability to provide predetermined size, as well as define alignment, means we need to account for either of these\n      // sources of padding when advancing the point we are reading in the buffer\n      const parseWithAlignment = (buffer, startOffset) => {\n        const { value, parsedSize } = parse(buffer, nanthrows(startOffset));\n\n        if (size != null && parsedSize > size) {\n          throw new Error(\n            `parsed size ${parsedSize} larger than predetermined size ${size} for field ${fieldName} on ${this.getName()}`\n          );\n        }\n\n        // when field is aligned we must make sure to advance by aligned size\n        // additionally, if a predetermined size is set, we should use that size instead (in case of padding)\n        // we have already asserted above that the parsed size is not larger than the predetermined size\n        let parsedSizeWithAlignment = getAlignedSizeForField(\n          field,\n          size != null ? size : parsedSize\n        );\n\n        if (size != null) {\n          const alignedExpectedSize = getAlignedSizeForField(field, size);\n\n          if (parsedSizeWithAlignment > alignedExpectedSize) {\n            throw new Error(\n              `aligned parsed size ${parsedSizeWithAlignment} larger than aligned predetermined size ${alignedExpectedSize} for field ${fieldName} on ${this.getName()}`\n            );\n          }\n        }\n\n        return { value, consumedSize: nanthrows(parsedSizeWithAlignment) };\n      };\n\n      // try {\n      if (field.arrayElements) {\n        // array field\n        const count =\n          typeof field.arrayElements === \"function\"\n            ? field.arrayElements(partialResult, contextData)\n            : field.arrayElements;\n        const array = new Array(count);\n\n        for (var i = 0; i < count; ++i) {\n          // console.log('getting array el', i, 'of', count, 'at', offset);\n          const { value, consumedSize } = parseWithAlignment(buffer, offset);\n\n          offset += nanthrows(consumedSize);\n          array[i] = value;\n        }\n\n        partialResult[fieldName] = array;\n      } else {\n        // non-array field\n        const { value, consumedSize } = parseWithAlignment(buffer, offset);\n        offset += nanthrows(consumedSize);\n        partialResult[fieldName] = value;\n      }\n      // } catch (error) {\n      //   throw new Error(\n      //     `failed parsing field ${fieldName} on ${this.getName()}: ${error}`\n      //   );\n      // }\n    });\n    if (isNaN(offset)) {\n      throw new Error(`invalid offset while parsing ${this.getName()}`);\n    }\n    this.lastOffset = offset;\n    return partialResult;\n  }\n\n  _getFieldConfig(fieldName, partialFieldData, contextData) {\n    const field = nullthrows(\n      this.schema.fields[fieldName],\n      `${fieldName} schema is missing`\n    );\n    const endian = field.endian || this.schema.endian || \"little\";\n    const type = nullthrows(field.type, `${fieldName} type`);\n    if (\n      !(\n        type instanceof BufferStructBase ||\n        type instanceof BufferStructUnion ||\n        type in FieldTypesToBufferMethods ||\n        BytesTypes.has(type)\n      )\n    ) {\n      throw new Error(`unsupported type ${type} in ${fieldName}`);\n    }\n\n    // use statically defined size if we've got it\n    let size =\n      typeof field.size === \"function\"\n        ? field.size(partialFieldData, contextData)\n        : field.size;\n    if (BytesTypes.has(type)) {\n      // allow size to be dynamic\n    } else if (type instanceof BufferStructBase) {\n      // allow size to be dynamic\n    } else if (type instanceof BufferStructUnion) {\n      // size will be statically known (asserted in BufferStructUnion)\n      size = type.size;\n    } else {\n      // size must be statically known\n      size = nullthrows(size, `${fieldName} size`);\n    }\n\n    let actualType = type;\n    // replace union type with actual type\n    if (type instanceof BufferStructUnion) {\n      actualType = type.selectMember(partialFieldData, contextData);\n      if (actualType == null) {\n        throw new Error(\n          `failed to refine union type in field ${fieldName} on ${this.getName()}`\n        );\n      }\n    }\n\n    return { field, endian, size, type: actualType };\n  }\n\n  serialize(data, contextData = null) {\n    if (!data) {\n      throw new Error(\n        `missing argument 'data' when serializing ${this.getName()}`\n      );\n    }\n    const parts = [];\n    Object.keys(this.schema.fields).forEach((fieldName) => {\n      const { field, endian, size, type } = this._getFieldConfig(\n        fieldName,\n        data,\n        contextData\n      );\n\n      let value;\n      if (!(fieldName in data)) {\n        if (\"default\" in field) {\n          value = field.default;\n        } else {\n          throw new Error(\n            `missing field ${fieldName} when serializing ${this.getName()}`\n          );\n        }\n      }\n      value = data[fieldName];\n\n      const serialize = BytesTypes.has(type)\n        ? (value) => {\n            let valueAsBuffer = value;\n            if (type === \"utf8\") {\n              valueAsBuffer = Buffer.from(value, \"utf8\");\n            }\n\n            const dynSize = size == null ? valueAsBuffer.length : size;\n            const partBuffer = Buffer.alloc(dynSize);\n            valueAsBuffer.copy(partBuffer, 0, 0, dynSize);\n\n            return partBuffer;\n          }\n        : type instanceof BufferStructBase\n        ? (value) => type.serialize(value, contextData)\n        : (value) => {\n            const methodName = `write${getBufferMethodName(\n              type,\n              size,\n              endian\n            )}`;\n\n            const partBuffer = Buffer.alloc(size);\n            partBuffer[methodName](value);\n            if (this.schema.traceWrites) {\n              console.log(methodName, {\n                fieldName,\n                type,\n                size,\n                endian,\n                value\n              });\n            }\n\n            return partBuffer;\n          };\n\n      const serializeWithAlignment = (value) => {\n        const partBuffer = serialize(value);\n        const serializedSize = partBuffer.length;\n        if (size != null && serializedSize > size) {\n          throw new Error(\n            `serialized size ${serializedSize} larger than predetermined size ${size} for field ${fieldName} on ${this.getName()}`\n          );\n        }\n\n        let maybeAlignedPartBuffer = partBuffer;\n        if (field.align != null) {\n          const alignedSerializedSize = getAlignedSize(\n            serializedSize,\n            field.align\n          );\n          const alignedExpectedSize = getAlignedSize(size, field.align);\n          if (alignedSerializedSize > alignedExpectedSize)\n            throw new Error(\n              `serialized aligned size ${\n                maybeAlignedPartBuffer.length\n              } larger than predetermined size (aligned) ${alignedExpectedSize} for field ${fieldName} on ${this.getName()}`\n            );\n\n          const partBufferAligned = Buffer.alloc(alignedSerializedSize);\n          partBuffer.copy(partBufferAligned);\n          maybeAlignedPartBuffer = partBufferAligned;\n        }\n\n        return maybeAlignedPartBuffer;\n      };\n\n      // try {\n      if (field.arrayElements) {\n        for (var i = 0; i < value.length; ++i) {\n          const part = serializeWithAlignment(value[i]);\n          parts.push(part);\n        }\n      } else {\n        const part = serializeWithAlignment(value);\n        parts.push(part);\n      }\n      // } catch (error) {\n      //   const extra = DEBUG ? `${error.stack} \\nrethrown stack:` : '';\n      //   throw new Error(\n      //     `failed serializing field ${fieldName}: ${error} ${extra}`\n      //   );\n      // }\n    });\n\n    return Buffer.concat(parts);\n  }\n\n  _staticSize = null;\n  getStaticSize() {\n    const prevSize = this._staticSize;\n    if (prevSize != null) {\n      return prevSize;\n    } else {\n      let size = 0;\n      for (const field of Object.values(this.schema.fields)) {\n        if (typeof field.size != \"number\") {\n          throw new Error(\n            \"cannot get static size of struct: \" + this.getName()\n          );\n        }\n        const alignedFieldSize = getAlignedSizeForField(field, field.size);\n        size += alignedFieldSize;\n      }\n      this._staticSize = size;\n      return size;\n    }\n  }\n}\n\n// simulates c struct union functionality, using the provided selectMember function\n// to choose which union member (BufferStruct) to interpret data as based on previously parsed fields.\n// requires that all union members have statically determinable size (eg. no arrays or dynamically sized bytes fields allowed)\n// when serializing, the maximum member size will be used\nclass BufferStructUnion {\n  constructor({ members, selectMember }) {\n    this.selectMember = selectMember;\n    this.members = members;\n    this.size = Math.max(...members.map((m) => m.getStaticSize()));\n  }\n}\n\nmodule.exports = {\n  BufferStruct,\n  BufferStructBase,\n  BufferStructUnion\n};\n","import \"./styles.css\";\nimport * as AIFF from \"./aiff\";\nimport { useState, useCallback } from \"react\";\n\nfunction readFile(file) {\n  return new Promise((resolve, reject) => {\n    const reader = new FileReader();\n    reader.readAsArrayBuffer(file);\n    reader.addEventListener(\"load\", () => {\n      resolve(reader.result);\n    });\n    reader.addEventListener(\"error\", () => {\n      reject(reader.error);\n    });\n  });\n}\n\nconst boxStyle = {\n  border: \"solid 1px black\"\n};\nconst textStyle = {\n  margin: \"8px 8px\",\n  wordWrap: \"break-word\"\n};\n\nfunction DisplayObject({ object }) {\n  return (\n    <div style={{ ...boxStyle, margin: \"8px 0px\" }}>\n      {Object.keys(object).map((key) => {\n        if (object[key] && typeof object[key] === \"object\") {\n          if (typeof object[key].length === \"number\") {\n            return (\n              <div key={key} style={textStyle}>\n                {key}:{\" \"}\n                {typeof object[key].length === \"number\" ? (\n                  `Buffer {size: ${object[key].length}}`\n                ) : (\n                  <DisplayObject object={object[key]} />\n                )}\n              </div>\n            );\n          }\n          return (\n            <div key={key} style={textStyle}>\n              {key}: <DisplayObject object={object[key]} />\n            </div>\n          );\n        }\n        return (\n          <div key={key} style={textStyle}>\n            {key}: {JSON.stringify(object[key])}\n          </div>\n        );\n      })}\n    </div>\n  );\n}\n\nfunction AiffChunk({ chunk }) {\n  const { ckID, ckSize, localChunks } = chunk;\n  const chunkSpecificData = chunk[ckID.toLowerCase()];\n\n  return (\n    <div style={{ ...boxStyle, margin: \"8px 0px\" }}>\n      <div style={textStyle}>chunk ID: {ckID}</div>\n      <div style={textStyle}>chunk size: {ckSize}</div>\n      {chunkSpecificData && (\n        <div style={textStyle}>\n          {ckID} chunk contents:{\" \"}\n          {typeof chunkSpecificData === \"object\" ? (\n            <DisplayObject object={chunkSpecificData} />\n          ) : (\n            JSON.stringify(chunkSpecificData)\n          )}\n        </div>\n      )}\n      {localChunks && (\n        <div style={textStyle}>\n          local chunks:\n          {localChunks.map((lchunk, i) => (\n            <AiffChunk key={i} chunk={lchunk} />\n          ))}\n        </div>\n      )}\n      <div style={{ ...textStyle, fontSize: \"0.8em\", color: \"#777\" }}>\n        end {ckID} chunk\n      </div>\n    </div>\n  );\n}\n\nexport default function App() {\n  const [aiff, setAiff] = useState(null);\n  const [error, setError] = useState(null);\n\n  const handleFiles = useCallback(async function handleFiles(e) {\n    const fileList =\n      e.currentTarget.files; /* now you can work with the file list */\n\n    const data = await readFile(fileList[0]);\n    try {\n      setAiff(AIFF.parse(new Buffer(data)));\n    } catch (err) {\n      setError(err);\n    }\n  }, []);\n\n  return (\n    <div className=\"App\">\n      <h1>AIFF explorer</h1>\n      <div>\n        <p>This tool visualizes the chunks in an AIFF file.</p>\n        <input type=\"file\" id=\"input\" onChange={handleFiles} />\n      </div>\n\n      {error && <pre>{error.toString() + \"\\n\" + error.stack}</pre>}\n      {aiff &&\n        aiff.fileChunks.map((chunk, i) => <AiffChunk key={i} chunk={chunk} />)}\n    </div>\n  );\n}\n"],"sourceRoot":""}