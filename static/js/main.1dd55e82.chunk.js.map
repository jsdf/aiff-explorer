{"version":3,"sources":["aiff.js","index.js","ieeeextended.js","bufferstruct.js","App.js"],"names":["ieeeExtended","require","BufferStruct","BufferStructBase","BufferStructUnion","PString","constructor","super","name","parse","buffer","startOffset","contextData","length","readUInt8","str","slice","toString","consumed","size","alignment","Math","ceil","this","lastOffset","serialize","data","Error","getName","parts","Buffer","from","push","alloc","concat","AIFFChunkStruct","endian","fields","ckID","type","ckSize","chunkData","align","AIFFCommonStruct","numChannels","numSampleFrames","sampleSize","sampleRate","AIFCCommonStruct","compressionType","compressionName","AIFCApplicationSpecificStruct","applicationSignature","context","dataSize","AIFFSoundDataStruct","offset","blockSize","soundData","soundDataSize","AIFFMarkerIdField","AIFFMarkerStruct","id","position","markerName","AIFFCommentStruct","timeStamp","marker","count","text","AIFFLoopStruct","playMode","beginLoop","endLoop","AIFFInstrumentStruct","baseNote","detune","lowNote","highNote","lowVelocity","highVelocity","gain","sustainLoop","releaseLoop","AIFFTextStruct","_","AIFCFormatStruct","timestamp","makeAIFFChunk","module","exports","form","appl","nsamples","floor","sampleRate80Bit","ConvertToIeeeExtended","formatChunk","commChunk","soundDataChunk","applChunks","map","applObj","formType","filter","Boolean","fileContents","pos","output","fileChunks","chunk","endOffset","formChunks","fileChunk","forEach","formChunk","localChunks","parsed","ConvertFromIeeeExtended","ssnd","format","fver","AIFFLoopPlayMode","NoLooping","ForwardLooping","ForwardBackwardLooping","rootElement","document","getElementById","ReactDOM","render","ldexp","x","exp","pow","FloatToUnsigned","f","UnsignedToFloat","u","bytes","expon","hiMant","loMant","Infinity","num","sign","fMant","fsMant","Array","fill","frexpRes","arg","result","Number","isFinite","absArg","abs","log2","n","log","LOG2E","max","frexp","nullthrows","value","message","nanthrows","isNaN","FieldTypesToBufferMethods","uint","int","float","double","bigint","biguint","char","BytesTypes","Set","getBufferMethodName","getAlignedSize","getAlignedSizeForField","field","schema","getStaticSize","members","selectMember","m","_staticSize","partialResult","Object","keys","fieldName","_getFieldConfig","has","valueAsBuffer","parsedSize","methodName","traceReads","console","parseWithAlignment","parsedSizeWithAlignment","alignedExpectedSize","consumedSize","arrayElements","array","i","partialFieldData","actualType","default","dynSize","partBuffer","copy","traceWrites","serializeWithAlignment","serializedSize","maybeAlignedPartBuffer","alignedSerializedSize","partBufferAligned","part","prevSize","values","readFile","file","Promise","resolve","reject","reader","FileReader","readAsArrayBuffer","addEventListener","error","boxStyle","border","textStyle","margin","wordWrap","DisplayObject","object","style","key","JSON","stringify","AiffChunk","chunkSpecificData","lchunk","fontSize","color","App","useState","aiff","setAiff","setError","handleFiles","useCallback","e","a","fileList","currentTarget","files","AIFF","err","className","onChange","stack"],"mappings":"yGAAA,kBAAMA,EAAeC,EAAQ,I,EAKzBA,EAAQ,IAHVC,E,EAAAA,aAEAC,G,EADAC,kB,EACAD,kBA6CF,MAAME,EAAU,IAnChB,cAA4BF,EAC1BG,cACEC,MAAM,CAACC,KAAM,YAEfC,MAAMC,EAAQC,EAAaC,EAAc,MACvC,MAAMC,EAASH,EAAOI,UAAUH,GAE1BI,EAAML,EACTM,MAAML,EAAc,EAAGA,EAAc,EAAIE,GACzCI,SAAS,QAENC,GAhBcC,EAgBY,EAAIN,EAhBVO,EAgBkB,EAfvCC,KAAKC,KAAKH,EAAOC,GAAaA,GADvC,IAAwBD,EAAMC,EAmB1B,OADAG,KAAKC,WAAab,EAAcO,EACzBH,EAGTU,UAAUC,EAAMd,EAAc,MAC5B,IAAKc,EACH,MAAM,IAAIC,MAAJ,mDACwCJ,KAAKK,YAIrD,MAAMC,EAAQ,CAACC,EAAOC,KAAK,CAACL,EAAKb,SAAUiB,EAAOC,KAAKL,IAOvD,OAJK,EAAIA,EAAKb,QAAU,IAAM,GAC5BgB,EAAMG,KAAKF,EAAOG,MAAM,IAGnBH,EAAOI,OAAOL,KAUnBM,EAAkB,IAAIjC,EAAa,CACvCM,KAAM,YACN4B,OAAQ,MACRC,OAAQ,CACNC,KAAM,CAACC,KAAM,OAAQpB,KAAM,GAC3BqB,OAAQ,CAACD,KAAM,MAAOpB,KAAM,GAC5BsB,UAAW,CAACF,KAAM,QAASG,MAAO,EAAGvB,KAAOkB,GAAWA,EAAOG,WAQ5DG,EAAmB,IAAIzC,EAAa,CACxCM,KAAM,aACN4B,OAAQ,MACRC,OAAQ,CACNO,YAAa,CAACL,KAAM,MAAOpB,KAAM,GACjC0B,gBAAiB,CAACN,KAAM,OAAQpB,KAAM,GACtC2B,WAAY,CAACP,KAAM,MAAOpB,KAAM,GAChC4B,WAAY,CAACR,KAAM,QAASpB,KAAM,OAUhC6B,EAAmB,IAAI9C,EAAa,CACxCM,KAAM,aACN4B,OAAQ,MACRC,OAAQ,CACNO,YAAa,CAACL,KAAM,MAAOpB,KAAM,GACjC0B,gBAAiB,CAACN,KAAM,OAAQpB,KAAM,GACtC2B,WAAY,CAACP,KAAM,MAAOpB,KAAM,GAChC4B,WAAY,CAACR,KAAM,QAASpB,KAAM,IAClC8B,gBAAiB,CAACV,KAAM,OAAQpB,KAAM,GACtC+B,gBAAiB,CAACX,KAAMlC,MAYtB8C,EAAgC,IAAIjD,EAAa,CACrDM,KAAM,0BACN4B,OAAQ,MACRC,OAAQ,CACNe,qBAAsB,CAACb,KAAM,OAAQpB,KAAM,GAC3CO,KAAM,CACJa,KAAM,QACNpB,KAAM,CAACkB,EAAQgB,IAAYA,EAAQC,aAQnCC,EAAsB,IAAIrD,EAAa,CAC3CM,KAAM,gBACN4B,OAAQ,MACRC,OAAQ,CACNmB,OAAQ,CAACjB,KAAM,OAAQpB,KAAM,GAC7BsC,UAAW,CAAClB,KAAM,OAAQpB,KAAM,GAChCuC,UAAW,CACTnB,KAAM,QACNpB,KAAM,CAACkB,EAAQgB,IAAYA,EAAQM,kBAMnCC,EAAoB,CAACrB,KAAM,MAAOpB,KAAM,GAMxC0C,EAAmB,IAAI3D,EAAa,CACxCM,KAAM,aACN4B,OAAQ,MACRC,OAAQ,CACNyB,GAAIF,EACJG,SAAU,CAACxB,KAAM,OAAQpB,KAAM,GAC/B6C,WAAY,CAACzB,KAAMlC,MAUjB4D,EAAoB,IAAI/D,EAAa,CACzCM,KAAM,cACN4B,OAAQ,MACRC,OAAQ,CACN6B,UAAW,CAAC3B,KAAM,OAAQpB,KAAM,GAChCgD,OAAQP,EACRQ,MAAO,CAAC7B,KAAM,OAAQpB,KAAM,GAC5BkD,KAAM,CAAC9B,KAAM,OAAQpB,KAAOkB,GAAWA,EAAO+B,UAe5CE,EAAiB,IAAIpE,EAAa,CACtCM,KAAM,WACN4B,OAAQ,MACRC,OAAQ,CACNkC,SAAU,CAAChC,KAAM,MAAOpB,KAAM,GAC9BqD,UAAWZ,EACXa,QAASb,KAePc,EAAuB,IAAIxE,EAAa,CAC5CM,KAAM,iBACN4B,OAAQ,MACRC,OAAQ,CACNsC,SAAU,CAACpC,KAAM,MAAOpB,KAAM,GAC9ByD,OAAQ,CAACrC,KAAM,MAAOpB,KAAM,GAC5B0D,QAAS,CAACtC,KAAM,MAAOpB,KAAM,GAC7B2D,SAAU,CAACvC,KAAM,MAAOpB,KAAM,GAC9B4D,YAAa,CAACxC,KAAM,MAAOpB,KAAM,GACjC6D,aAAc,CAACzC,KAAM,MAAOpB,KAAM,GAClC8D,KAAM,CAAC1C,KAAM,MAAOpB,KAAM,GAC1B+D,YAAa,CAAC3C,KAAM+B,GACpBa,YAAa,CAAC5C,KAAM+B,MAYlBc,EAAiB,IAAIlF,EAAa,CACtCM,KAAM,WACN4B,OAAQ,MACRC,OAAQ,CACNgC,KAAM,CAAC9B,KAAM,OAAQpB,KAAM,CAACkE,EAAGhC,IAAYA,EAAQC,aAMjDgC,EAAmB,IAAIpF,EAAa,CACxCM,KAAM,aACN4B,OAAQ,MACRC,OAAQ,CACNkD,UAAW,CAAChD,KAAM,OAAQpB,KAAM,MAIpC,SAASqE,EAAclD,EAAMG,GAC3B,OAAON,EAAgBV,UAAU,CAC/Ba,OACAE,OAAQC,EAAU5B,OAClB4B,cAoOJgD,EAAOC,QAAU,CACfjE,UAjOF,UAAuB,UACrBiC,EADqB,YAErBd,EAFqB,WAGrBG,EAHqB,WAIrBD,EAJqB,KAKrB6C,EALqB,gBAMrB1C,EANqB,gBAOrBC,EAPqB,KAQrB0C,IAEA,MAAMC,EAAWxE,KAAKyE,MACpBpC,EAAU7C,OAAS+B,GAAeE,EAAa,IAE3CiD,EAAkBjE,EAAOC,KAC7B/B,EAAagG,sBAAsBjD,IAI/BkD,EACK,SAATN,EACIH,EACE,OACAF,EAAiB7D,UAAU,CACzB8D,UAzCS,cA4Cb,KAEAW,EAAYV,EAChB,OACS,SAATG,EACI3C,EAAiBvB,UAAU,CACzBmB,cACAC,gBAAiBgD,EACjB/C,aACAC,WAAYgD,EACZ9C,kBACAC,oBAEFP,EAAiBlB,UAAU,CACzBmB,cACAC,gBAAiBgD,EACjB/C,aACAC,WAAYgD,KAIdI,EAAiBX,EACrB,OACA1D,EAAOI,OAAO,CACZqB,EAAoB9B,UAClB,CACE+B,OAAQ,EACRC,UAAW,EACXC,aAEF,CACEC,cAAeD,EAAU7C,YAM3BuF,EACK,SAATT,GAAmBC,EACfA,EAAKS,KAAKC,GACRd,EACE,OACA1D,EAAOI,OAAO,CACZiB,EAA8B1B,UAAU6E,EAAS,CAC/ChD,SAAUgD,EAAQ5E,KAAKb,cAK/B,GAEA0F,EAAWzE,EAAOC,KAAc,SAAT4D,EAAkB,OAAS,OAAQ,QAWhE,OATyBH,EACvB,OACA1D,EAAOI,OACL,CAACqE,EAAUN,EAAaC,EAAWC,KAAmBC,GAAYI,OAChEC,YA+INhG,MAvIF,SAAmBiG,GACjB,IAAIC,EAAM,EAENC,EAAS,GAEb,MAAMC,EAAa,GACnB,KAAOF,EAAMD,EAAa7F,QAAQ,CAShC,MAAMiG,EAAQ3E,EAAgB1B,MAAMiG,EAAcC,GAClDG,EAAMnG,YAAcgG,EACpBG,EAAMC,UAAY5E,EAAgBX,WAClCqF,EAAW7E,KAAK8E,GAChBH,EAAMxE,EAAgBX,WAKxB,MAAMwF,EAAaH,EAAWL,QAC3BS,GAAiC,SAAnBA,EAAU3E,OAyG3B,OAvGA0E,EAAWE,SAASC,IAClB,IAAIR,EAAM,EAEVQ,EAAUxB,KAAOwB,EAAU1E,UAAUzB,MAAM,EAAG,GAAGC,SAAS,QAC1D2F,EAAOjB,KAAOwB,EAAUxB,KACxBgB,GAAO,EAGP,MAAMS,EAAc,GACpB,KAAOT,EAAMQ,EAAU1E,UAAU5B,QAAQ,CAQvC,MAAMiG,EAAQ3E,EAAgB1B,MAAM0G,EAAU1E,UAAWkE,GAWzD,OAVAG,EAAMnG,YAAcgG,EACpBG,EAAMC,UAAY5E,EAAgBX,WAE9BsF,EAAMtE,OAOFsE,EAAMxE,MACZ,IAAK,OACHwE,EAAMO,OACe,SAAnBF,EAAUxB,KACN3C,EAAiBvC,MAAMqG,EAAMrE,WAC7BE,EAAiBlC,MAAMqG,EAAMrE,WACnCqE,EAAMO,OAAOtE,WAAa/C,EAAasH,wBACrCR,EAAMO,OAAOtE,YAEf+D,EAAMO,OAASP,EAAMO,OAErBT,EAAO7D,WAAa+D,EAAMO,OAAOtE,WACjC6D,EAAO9D,WAAagE,EAAMO,OAAOvE,WACjC8D,EAAOhE,YAAckE,EAAMO,OAAOzE,YAClCgE,EAAO3D,gBAAkB6D,EAAMO,OAAOpE,gBACtC2D,EAAO1D,gBAAkB4D,EAAMO,OAAOnE,gBACtC,MACF,IAAK,OACH4D,EAAMO,OAAS9D,EAAoB9C,MAAMqG,EAAMrE,UAAW,EAAG,CAC3DkB,cACEmD,EAAMtE,OAxS8B,IA0SxCsE,EAAMS,KAAOT,EAAMO,OACnBT,EAAOlD,UAAYoD,EAAMO,OAAO3D,UAChC,MACF,IAAK,OACHoD,EAAMO,OAASxD,EAAiBpD,MAAMqG,EAAMrE,UAAW,GACvD,MACF,IAAK,OACHqE,EAAMO,OAASpD,EAAkBxD,MAAMqG,EAAMrE,UAAW,GACxD,MACF,IAAK,OACHqE,EAAMO,OAAS3C,EAAqBjE,MAAMqG,EAAMrE,UAAW,GAC3D,MACF,IAvNgB,OAwNhB,IAvNkB,OAwNlB,IAvNqB,OAwNrB,IAvNsB,OAwNpBqE,EAAMO,OAASjC,EAAe3E,MAAMqG,EAAMrE,UAAW,EAAG,CACtDa,SAAUwD,EAAMtE,SAElB,MACF,IAAK,OACHsE,EAAMO,OAASlE,EAA8B1C,MAC3CqG,EAAMrE,UACN,EACA,CACEa,SAAUwD,EAAMtE,OAlVS,IAqV7BsE,EAAMlB,KAAOkB,EAAMO,OACnBT,EAAOhB,KAAOgB,EAAOhB,MAAQ,GAC7BgB,EAAOhB,KAAK5D,KAAK8E,EAAMO,QACvB,MACF,IAAK,OACHP,EAAMO,OAAS/B,EAAiB7E,MAAMqG,EAAMrE,WAC5CqE,EAAMU,OAASV,EAAMO,OACrB,MACF,IAAK,OACHP,EAAMO,OAAS/B,EAAiB7E,MAAMqG,EAAMrE,WAC5CqE,EAAMW,KAAOX,EAAMO,OAQvBD,EAAYpF,KAAK8E,GACjBH,EAAMxE,EAAgBX,WAExB2F,EAAUC,YAAcA,KAE1BR,EAAOC,WAAaA,EACpBD,EAAOI,WAAaA,EACbJ,GAMPvG,UACAqH,iBAtTuB,CACvBC,UAAW,EACXC,eAAgB,EAChBC,uBAAwB,M,wGCvK1B,MAAMC,EAAcC,SAASC,eAAe,QAC5CC,IAASC,OACP,cAAC,aAAD,UACE,cAAC,IAAD,MAEFJ,I,sCCTF,MAAMK,EAAQ,CAACC,EAAGC,IAAQD,EAAI/G,KAAKiH,IAAI,EAAGD,GA8C1C,MAAME,EAAmBC,GAAMA,EAAI,WAAe,WAAa,EAkE/D,MAAMC,EAAmBC,IAAQA,EAAI,WAAc,GAAK,EAAI,WAwC5DjD,EAAOC,QAAU,CACf4B,wBAnCF,SAAoDqB,GAClD,IAAeH,EACHI,EACUC,EAAQC,EA2B9B,OAzBAF,GAAqB,IAAXD,EAAM,KAAc,EAAiB,IAAXA,EAAM,GAC1CE,GACe,IAAXF,EAAM,KAAc,IACT,IAAXA,EAAM,KAAc,IACT,IAAXA,EAAM,KAAc,EACV,IAAXA,EAAM,GACTG,GACe,IAAXH,EAAM,KAAc,IACT,IAAXA,EAAM,KAAc,IACT,IAAXA,EAAM,KAAc,EACV,IAAXA,EAAM,GAEI,GAATC,GAAwB,GAAVC,GAAyB,GAAVC,EAC/BN,EAAI,EAES,OAATI,EAEFJ,EAAIO,KAEJH,GAAS,MACTJ,EAAIL,EAAMM,EAAgBI,GAAUD,GAAS,IAC7CJ,GAAKL,EAAMM,EAAgBK,GAAUF,GAAS,KAInC,IAAXD,EAAM,IAAmBH,EACjBA,GAKZxC,sBA1GF,SAA0CgD,GACxC,IACYC,EACAL,EACGM,EAAOC,EACAN,EAAQC,EAJhBH,EAAQ,IAAIS,MAAM,IAAIC,KAAK,GAazC,GAPIL,EAAM,GACRC,EAAO,MACPD,IAAQ,GAERC,EAAO,EAGE,GAAPD,EACFJ,EAAQ,EACRC,EAAS,EACTC,EAAS,MACJ,CACL,MAAMQ,EA/DV,SAAeC,GAGb,MAAMC,EAAS,CAFfD,EAAME,OAAOF,GAEQ,GAErB,GAAY,IAARA,GAAaE,OAAOC,SAASH,GAAM,CACrC,MAAMI,EAAStI,KAAKuI,IAAIL,GAElBM,EACJxI,KAAKwI,MACL,SAAcC,GACZ,OAAOzI,KAAK0I,IAAID,GAAKzI,KAAK2I,OAE9B,IAAI3B,EAAMhH,KAAK4I,KAAK,KAAM5I,KAAKyE,MAAM+D,EAAKF,IAAW,GACjDvB,EAAIuB,EAAStI,KAAKiH,IAAI,GAAID,GAI9B,KAAOD,EAAI,IACTA,GAAK,EACLC,IAEF,KAAOD,GAAK,GACVA,GAAK,GACLC,IAGEkB,EAAM,IACRnB,GAAKA,GAEPoB,EAAO,GAAKpB,EACZoB,EAAO,GAAKnB,EAEd,OAAOmB,EA8BYU,CAAMlB,GACvBE,EAAQI,EAAS,GACjBV,EAAQU,EAAS,GAEbV,EAAQ,SAAWM,EAAQ,IAE7BN,EAAe,MAAPK,EACRJ,EAAS,EACTC,EAAS,IAGTF,GAAS,MACLA,EAAQ,IAEVM,EAAQf,EAAMe,EAAON,GACrBA,EAAQ,GAEVA,GAASK,EACTC,EAAQf,EAAMe,EAAO,IACrBC,EAAS9H,KAAKyE,MAAMoD,GACpBL,EAASN,EAAgBY,GACzBD,EAAQf,EAAMe,EAAQC,EAAQ,IAC9BA,EAAS9H,KAAKyE,MAAMoD,GACpBJ,EAASP,EAAgBY,IAe7B,OAXAR,EAAM,GAAKC,GAAS,EACpBD,EAAM,GAAKC,EACXD,EAAM,GAAKE,GAAU,GACrBF,EAAM,GAAKE,GAAU,GACrBF,EAAM,GAAKE,GAAU,EACrBF,EAAM,GAAKE,EACXF,EAAM,GAAKG,GAAU,GACrBH,EAAM,GAAKG,GAAU,GACrBH,EAAM,GAAKG,GAAU,EACrBH,EAAM,GAAKG,EAEJH,K,oBC1GT,YAEA,SAASwB,EAAWC,EAAOC,GACzB,GAAa,MAATD,EACF,MAAM,IAAIzI,MAAM,mBAAqB0I,EAAU,KAAOA,EAAU,KAElE,OAAOD,EAGT,SAASE,EAAUF,EAAOC,GACxB,GAAIE,MAAMH,GACR,MAAM,IAAIzI,MAAM,kBAAoB0I,EAAU,KAAOA,EAAU,KAEjE,OAAOD,EAGT,MAAMI,EAA4B,CAChCC,KAAM,OACNC,IAAK,MACLC,MAAO,QACPC,OAAQ,SACRC,OAAQ,SACRC,QAAS,UACTC,KAAM,QAGFC,EAAa,IAAIC,IAAI,CAAC,QAAS,SAErC,SAASC,EAAoB3I,EAAMpB,EAAMiB,GACvC,MAAM,GAAN,OAAUoI,EAA0BjI,IAApC,OAAmD,EAAPpB,GAA5C,OACU,GAARA,EAAY,GAAe,OAAViB,EAAkB,KAAO,MAI9C,SAAS+I,EAAehK,EAAMC,GAC5B,OAAOC,KAAKC,KAAKH,EAAOC,GAAaA,EAGvC,SAASgK,EAAuBC,EAAOlK,GACrC,OAAsB,MAAfkK,EAAM3I,MACTyI,EAAeb,EAAUnJ,GAAOmJ,EAAUe,EAAM3I,QAChD4H,EAAUnJ,GAyBhB,MAAMhB,EACJG,YAAYgL,GACV/J,KAAK+J,OAASA,EACd/J,KAAKC,WAAa,EAGpBf,MAAMC,EAAQC,EAAaC,EAAc,OAIzCa,UAAUC,EAAMd,EAAc,OAI9B2K,gBACE,MAAM,IAAI5J,MACR,qCAAuCJ,KAAKjB,YAAYE,MAI5DoB,UACE,OAAOL,KAAK+J,OAAO9K,MAAQe,KAAKjB,YAAYE,MAoUhD,MAAMJ,EACJE,aAAY,QAAEkL,EAAF,aAAWC,IACrBlK,KAAKkK,aAAeA,EACpBlK,KAAKiK,QAAUA,EACfjK,KAAKJ,KAAOE,KAAK4I,OAAOuB,EAAQnF,KAAKqF,GAAMA,EAAEH,oBAIjD9F,EAAOC,QAAU,CACfxF,aAzUF,cAA2BC,EAAkB,eAAD,oBAsS1CwL,YAAc,KArSdlL,MAAMC,EAAQC,EAAaC,EAAc,MACvC,MAAMgL,EAAgB,GACtB,IAAIpI,EAAS7C,GAAe,EAwH5B,GAvHAkL,OAAOC,KAAKvK,KAAK+J,OAAOjJ,QAAQ6E,SAAS6E,IAAe,MAAD,EACfxK,KAAKyK,gBACzCD,EACAH,EACAhL,GAHMyK,EAD6C,EAC7CA,MAAOjJ,EADsC,EACtCA,OAAQjB,EAD8B,EAC9BA,KAAMoB,EADwB,EACxBA,KAMvB9B,EAAQuK,EAAWiB,IAAI1J,GACzB,CAAC7B,EAAQC,KACP,GAAY,MAARQ,EACF,MAAM,IAAIQ,MAAJ,gEAIR,GAAIjB,EAAOG,OAASF,EAAcQ,EAChC,MAAM,IAAIQ,MAAJ,wBACaR,EADb,2BAEFT,EAAOG,OAASF,EAFd,gCAGoBoL,EAHpB,eAGoCxK,KAAKK,YAGjD,MAAMsK,EAAgBxL,EAAOM,MAAML,EAAaA,EAAcQ,GAC9D,IAAIiJ,EAAQ8B,EAIZ,MAHa,SAAT3J,IACF6H,EAAQ8B,EAAcjL,SAAS,SAE1B,CAAEmJ,QAAO+B,WAAYhL,IAE9BoB,aAAgBpC,EAChB,CAACO,EAAQC,KAQA,CAAEyJ,MANK7H,EAAK9B,MAAMC,EAAQC,EAAaC,GAM9BuL,WAHN,MAARhL,EAAeA,EAAOoB,EAAKf,WAAab,IAK5C,CAACD,EAAQC,KACP,MAAMyL,EAAU,cAAUlB,EAAoB3I,EAAMpB,EAAMiB,IAEpDgI,EAAQ1J,EAAO0L,GAAYzL,GAYjC,OAXIY,KAAK+J,OAAOe,YACdC,QAAQvC,IAAIqC,EAAY,CACtBL,YACAxJ,OACApB,OACAiB,SACAzB,cACAyJ,UAIG,CAAEA,QAAO+B,WAAYhL,IAK5BoL,EAAqB,CAAC7L,EAAQC,KAAiB,MAAD,EACpBF,EAAMC,EAAQ4J,EAAU3J,IAA9CyJ,EAD0C,EAC1CA,MAAO+B,EADmC,EACnCA,WAEf,GAAY,MAARhL,GAAgBgL,EAAahL,EAC/B,MAAM,IAAIQ,MAAJ,sBACWwK,EADX,2CACwDhL,EADxD,sBAC0E4K,EAD1E,eAC0FxK,KAAKK,YAOvG,IAAI4K,EAA0BpB,EAC5BC,EACQ,MAARlK,EAAeA,EAAOgL,GAGxB,GAAY,MAARhL,EAAc,CAChB,MAAMsL,EAAsBrB,EAAuBC,EAAOlK,GAE1D,GAAIqL,EAA0BC,EAC5B,MAAM,IAAI9K,MAAJ,8BACmB6K,EADnB,mDACqFC,EADrF,sBACsHV,EADtH,eACsIxK,KAAKK,YAKrJ,MAAO,CAAEwI,QAAOsC,aAAcpC,EAAUkC,KAI1C,GAAInB,EAAMsB,cAAe,CAEvB,MAAMvI,EAC2B,oBAAxBiH,EAAMsB,cACTtB,EAAMsB,cAAcf,EAAehL,GACnCyK,EAAMsB,cACNC,EAAQ,IAAIxD,MAAMhF,GAExB,IAAK,IAAIyI,EAAI,EAAGA,EAAIzI,IAASyI,EAAG,SAEEN,EAAmB7L,EAAQ8C,GAAnD4G,EAFsB,EAEtBA,MAAOsC,EAFe,EAEfA,aAEflJ,GAAU8G,EAAUoC,GACpBE,EAAMC,GAAKzC,EAGbwB,EAAcG,GAAaa,MACtB,SAE2BL,EAAmB7L,EAAQ8C,GAAnD4G,EAFH,EAEGA,MAAOsC,EAFV,EAEUA,aACflJ,GAAU8G,EAAUoC,GACpBd,EAAcG,GAAa3B,MAQ3BG,MAAM/G,GACR,MAAM,IAAI7B,MAAJ,uCAA0CJ,KAAKK,YAGvD,OADAL,KAAKC,WAAagC,EACXoI,EAGTI,gBAAgBD,EAAWe,EAAkBlM,GAC3C,MAAMyK,EAAQlB,EACZ5I,KAAK+J,OAAOjJ,OAAO0J,GADG,UAEnBA,EAFmB,uBAIlB3J,EAASiJ,EAAMjJ,QAAUb,KAAK+J,OAAOlJ,QAAU,SAC/CG,EAAO4H,EAAWkB,EAAM9I,KAAP,UAAgBwJ,EAAhB,UACvB,KAEIxJ,aAAgBpC,GAChBoC,aAAgBnC,GAChBmC,KAAQiI,GACRQ,EAAWiB,IAAI1J,IAGjB,MAAM,IAAIZ,MAAJ,2BAA8BY,EAA9B,eAAyCwJ,IAIjD,IAAI5K,EACoB,oBAAfkK,EAAMlK,KACTkK,EAAMlK,KAAK2L,EAAkBlM,GAC7ByK,EAAMlK,KACR6J,EAAWiB,IAAI1J,IAERA,aAAgBpC,IAIzBgB,EAFSoB,aAAgBnC,EAElBmC,EAAKpB,KAGLgJ,EAAWhJ,EAAD,UAAU4K,EAAV,WAGnB,IAAIgB,EAAaxK,EAEjB,GAAIA,aAAgBnC,IAClB2M,EAAaxK,EAAKkJ,aAAaqB,EAAkBlM,GAC/B,MAAdmM,GACF,MAAM,IAAIpL,MAAJ,+CACoCoK,EADpC,eACoDxK,KAAKK,YAKnE,MAAO,CAAEyJ,QAAOjJ,SAAQjB,OAAMoB,KAAMwK,GAGtCtL,UAAUC,EAAMd,EAAc,MAC5B,IAAKc,EACH,MAAM,IAAIC,MAAJ,mDACwCJ,KAAKK,YAGrD,MAAMC,EAAQ,GA0Gd,OAzGAgK,OAAOC,KAAKvK,KAAK+J,OAAOjJ,QAAQ6E,SAAS6E,IAAe,MAAD,EACfxK,KAAKyK,gBACzCD,EACArK,EACAd,GAHMyK,EAD6C,EAC7CA,MAAOjJ,EADsC,EACtCA,OAAQjB,EAD8B,EAC9BA,KAAMoB,EADwB,EACxBA,KAM7B,IAAI6H,EACJ,KAAM2B,KAAarK,GAAO,CACxB,KAAI,YAAa2J,GAGf,MAAM,IAAI1J,MAAJ,wBACaoK,EADb,6BAC2CxK,KAAKK,YAHtDwI,EAAQiB,EAAM2B,QAOlB5C,EAAQ1I,EAAKqK,GAEb,MAAMtK,EAAYuJ,EAAWiB,IAAI1J,GAC5B6H,IACC,IAAI8B,EAAgB9B,EACP,SAAT7H,IACF2J,EAAgBpK,EAAOC,KAAKqI,EAAO,SAGrC,MAAM6C,EAAkB,MAAR9L,EAAe+K,EAAcrL,OAASM,EAChD+L,EAAapL,EAAOG,MAAMgL,GAGhC,OAFAf,EAAciB,KAAKD,EAAY,EAAG,EAAGD,GAE9BC,GAET3K,aAAgBpC,EACfiK,GAAU7H,EAAKd,UAAU2I,EAAOxJ,GAChCwJ,IACC,MAAMgC,EAAU,eAAWlB,EACzB3I,EACApB,EACAiB,IAGI8K,EAAapL,EAAOG,MAAMd,GAYhC,OAXA+L,EAAWd,GAAYhC,GACnB7I,KAAK+J,OAAO8B,aACdd,QAAQvC,IAAIqC,EAAY,CACtBL,YACAxJ,OACApB,OACAiB,SACAgI,UAIG8C,GAGPG,EAA0BjD,IAC9B,MAAM8C,EAAazL,EAAU2I,GACvBkD,EAAiBJ,EAAWrM,OAClC,GAAY,MAARM,GAAgBmM,EAAiBnM,EACnC,MAAM,IAAIQ,MAAJ,0BACe2L,EADf,2CACgEnM,EADhE,sBACkF4K,EADlF,eACkGxK,KAAKK,YAI/G,IAAI2L,EAAyBL,EAC7B,GAAmB,MAAf7B,EAAM3I,MAAe,CACvB,MAAM8K,EAAwBrC,EAC5BmC,EACAjC,EAAM3I,OAEF+J,EAAsBtB,EAAehK,EAAMkK,EAAM3I,OACvD,GAAI8K,EAAwBf,EAC1B,MAAM,IAAI9K,MAAJ,kCAEF4L,EAAuB1M,OAFrB,qDAGyC4L,EAHzC,sBAG0EV,EAH1E,eAG0FxK,KAAKK,YAGvG,MAAM6L,EAAoB3L,EAAOG,MAAMuL,GACvCN,EAAWC,KAAKM,GAChBF,EAAyBE,EAG3B,OAAOF,GAIT,GAAIlC,EAAMsB,cACR,IAAK,IAAIE,EAAI,EAAGA,EAAIzC,EAAMvJ,SAAUgM,EAAG,CACrC,MAAMa,EAAOL,EAAuBjD,EAAMyC,IAC1ChL,EAAMG,KAAK0L,OAER,CACL,MAAMA,EAAOL,EAAuBjD,GACpCvI,EAAMG,KAAK0L,OAUR5L,EAAOI,OAAOL,GAIvB0J,gBACE,MAAMoC,EAAWpM,KAAKoK,YACtB,GAAgB,MAAZgC,EACF,OAAOA,EACF,CACL,IAAIxM,EAAO,EACX,cAAoB0K,OAAO+B,OAAOrM,KAAK+J,OAAOjJ,QAA9C,eAAuD,CAAlD,MAAMgJ,EAAK,KACd,GAAyB,iBAAdA,EAAMlK,KACf,MAAM,IAAIQ,MACR,qCAAuCJ,KAAKK,WAIhDT,GADyBiK,EAAuBC,EAAOA,EAAMlK,MAI/D,OADAI,KAAKoK,YAAcxK,EACZA,KAmBXhB,mBACAC,uB,6KClaF,SAASyN,EAASC,GAChB,OAAO,IAAIC,SAAQ,CAACC,EAASC,KAC3B,MAAMC,EAAS,IAAIC,WACnBD,EAAOE,kBAAkBN,GACzBI,EAAOG,iBAAiB,QAAQ,KAC9BL,EAAQE,EAAO1E,WAEjB0E,EAAOG,iBAAiB,SAAS,KAC/BJ,EAAOC,EAAOI,aAKpB,MAAMC,EAAW,CACfC,OAAQ,mBAEJC,EAAY,CAChBC,OAAQ,UACRC,SAAU,cAGZ,SAASC,GAAc,OAACC,IACtB,OACE,qBAAKC,MAAK,2BAAMP,GAAN,IAAgBG,OAAQ,YAAlC,SACG7C,OAAOC,KAAK+C,GAAQxI,KAAK0I,GACpBF,EAAOE,IAA+B,kBAAhBF,EAAOE,GACG,kBAAvBF,EAAOE,GAAKlO,OAEnB,sBAAeiO,MAAOL,EAAtB,UACGM,EADH,IACS,IACwB,kBAAvBF,EAAOE,GAAKlO,OAAnB,wBACkBgO,EAAOE,GAAKlO,OAD9B,KAGC,cAAC+N,EAAD,CAAeC,OAAQA,EAAOE,OALxBA,GAWZ,sBAAeD,MAAOL,EAAtB,UACGM,EADH,KACS,cAACH,EAAD,CAAeC,OAAQA,EAAOE,OAD7BA,GAMZ,sBAAeD,MAAOL,EAAtB,UACGM,EADH,KACUC,KAAKC,UAAUJ,EAAOE,MADtBA,OASpB,SAASG,GAAU,MAACpI,IAAS,MACpBxE,EAA6BwE,EAA7BxE,KAAME,EAAuBsE,EAAvBtE,OAAQ4E,EAAeN,EAAfM,YACrB,IAAI+H,EAAoBrI,EAAMO,OAK9B,MAJa,SAAT/E,IACF6M,EAAoB,CAAC5I,SAAUO,EAAMnB,OAIrC,sBAAKmJ,MAAK,2BAAMP,GAAN,IAAgBG,OAAQ,YAAlC,UACE,sBAAKI,MAAOL,EAAZ,uBAAkCnM,KAClC,sBAAKwM,MAAOL,EAAZ,yBAAoCjM,KACnC2M,GACC,sBAAKL,MAAOL,EAAZ,UACGnM,EADH,WACiB,IACe,kBAAtB6M,EACN,cAACP,EAAD,CAAeC,OAAQM,IAEvBH,KAAKC,UAAUE,MAIpB/H,GACC,sBAAK0H,MAAOL,EAAZ,0BAEGrH,EAAYf,KAAI,CAAC+I,EAAQvC,IACxB,cAACqC,EAAD,CAAmBpI,MAAOsI,GAAVvC,QAItB,sBAAKiC,MAAK,2BAAML,GAAN,IAAiBY,SAAU,QAASC,MAAO,SAArD,iBACOhN,EADP,eAOS,SAASiN,IAAO,MAAD,EACJC,mBAAS,MADL,mBACrBC,EADqB,KACfC,EADe,OAEFF,mBAAS,MAFP,mBAErBlB,EAFqB,KAEdqB,EAFc,KAItBC,EAAcC,sBAAW,uCAAC,WAA2BC,GAA3B,iBAAAC,EAAA,6DACxBC,EACJF,EAAEG,cAAcC,MAFY,SAIXrC,EAASmC,EAAS,IAJP,OAIxBtO,EAJwB,OAK9B,IACEgO,EAAQS,QAAW,IAAIrO,EAAOJ,KAC9B,MAAO0O,GACPT,EAASS,GARmB,2CAAD,gBAAC,GAAD,mCAU5B,IAEH,OACE,sBAAKC,UAAU,MAAf,UACE,+CACA,gCACE,iFACA,uBAAO9N,KAAK,OAAOuB,GAAG,QAAQwM,SAAUV,OAGzCtB,GAAS,8BAAMA,EAAMrN,WAAa,KAAOqN,EAAMiC,QAC/Cd,GACCA,EAAK5I,WAAWR,KAAI,CAACS,EAAO+F,IAAM,cAACqC,EAAD,CAAmBpI,MAAOA,GAAV+F,W","file":"static/js/main.1dd55e82.chunk.js","sourcesContent":["const ieeeExtended = require('./ieeeextended');\nconst {\n  BufferStruct,\n  BufferStructUnion,\n  BufferStructBase,\n} = require('./bufferstruct');\n\nconst DEBUG = false;\n\nfunction getAlignedSize(size, alignment) {\n  return Math.ceil(size / alignment) * alignment;\n}\n\n// pascal-style string\nclass PStringParser extends BufferStructBase {\n  constructor() {\n    super({name: 'PString'});\n  }\n  parse(buffer, startOffset, contextData = null) {\n    const length = buffer.readUInt8(startOffset);\n\n    const str = buffer\n      .slice(startOffset + 1, startOffset + 1 + length)\n      .toString('utf8');\n\n    const consumed = getAlignedSize(1 + length, 2); // pad to multiple of 2\n\n    this.lastOffset = startOffset + consumed;\n    return str;\n  }\n\n  serialize(data, contextData = null) {\n    if (!data) {\n      throw new Error(\n        `missing argument 'data' when serializing ${this.getName()}`\n      );\n    }\n\n    const parts = [Buffer.from([data.length]), Buffer.from(data)];\n\n    // pad to even size\n    if ((1 + data.length) % 2 === 1) {\n      parts.push(Buffer.alloc(1));\n    }\n\n    return Buffer.concat(parts);\n  }\n}\n\nconst PString = new PStringParser();\n\n// AIFF stuff\n// http://paulbourke.net/dataformats/audio/\n// http://www-mmsp.ece.mcgill.ca/Documents/AudioFormats/AIFF/Docs/AIFF-1.3.pdf\n// http://www-mmsp.ece.mcgill.ca/Documents/AudioFormats/AIFF/Docs/AIFF-C.9.26.91.pdf\nconst AIFFChunkStruct = new BufferStruct({\n  name: 'AIFFChunk',\n  endian: 'big',\n  fields: {\n    ckID: {type: 'utf8', size: 4},\n    ckSize: {type: 'int', size: 4},\n    chunkData: {type: 'bytes', align: 2, size: (fields) => fields.ckSize},\n  },\n});\n\n// short numChannels;\n// unsigned long numSampleFrames;\n// short sampleSize;\n// extended sampleRate;\nconst AIFFCommonStruct = new BufferStruct({\n  name: 'AIFFCommon',\n  endian: 'big',\n  fields: {\n    numChannels: {type: 'int', size: 2},\n    numSampleFrames: {type: 'uint', size: 4},\n    sampleSize: {type: 'int', size: 2},\n    sampleRate: {type: 'bytes', size: 10},\n  },\n});\n\n// short numChannels; /* # audio channels */\n// unsigned long numSampleFrames; /* # sample frames = samples/channel */\n// short sampleSize; /* # bits/sample */\n// extended sampleRate; /* sample_frames/sec */\n// ID compressionType; /* compression type ID code */\n// pstring compressionName; /* human-readable compression type name */\nconst AIFCCommonStruct = new BufferStruct({\n  name: 'AIFCCommon',\n  endian: 'big',\n  fields: {\n    numChannels: {type: 'int', size: 2},\n    numSampleFrames: {type: 'uint', size: 4},\n    sampleSize: {type: 'int', size: 2},\n    sampleRate: {type: 'bytes', size: 10},\n    compressionType: {type: 'utf8', size: 4},\n    compressionName: {type: PString},\n  },\n});\n\n// #define ApplicationSpecificID 'APPL' /* ckID for Application Specific Chunk */\n// typedef struct {\n// ID ckID; /* 'APPL' */\n// long ckDataSize;\n// OSType applicationSignature;\n// char data[];\n// } ApplicationSpecificChunk;\nconst AIFC_APPL_CHUNK_SIZE_EXCL_DATA = 4; // sum of fixed-size fields\nconst AIFCApplicationSpecificStruct = new BufferStruct({\n  name: 'AIFCApplicationSpecific',\n  endian: 'big',\n  fields: {\n    applicationSignature: {type: 'utf8', size: 4},\n    data: {\n      type: 'bytes',\n      size: (fields, context) => context.dataSize,\n    },\n  },\n});\n\n// unsigned long offset;\n// unsigned long blockSize;\nconst AIFF_SOUND_DATA_CHUNK_SIZE_EXCL_SOUNDDATA = 8; // sum of fixed-size fields\nconst AIFFSoundDataStruct = new BufferStruct({\n  name: 'AIFFSoundData',\n  endian: 'big',\n  fields: {\n    offset: {type: 'uint', size: 4},\n    blockSize: {type: 'uint', size: 4},\n    soundData: {\n      type: 'bytes',\n      size: (fields, context) => context.soundDataSize,\n    },\n  },\n});\n\n// typedef short MarkerId;\nconst AIFFMarkerIdField = {type: 'int', size: 2};\n//   typedef struct {\n//   MarkerId id; /* must be > 0 */\n//   unsigned long position; /* sample frame number */\n//   pstring markerName;\n// } Marker;\nconst AIFFMarkerStruct = new BufferStruct({\n  name: 'AIFFMarker',\n  endian: 'big',\n  fields: {\n    id: AIFFMarkerIdField,\n    position: {type: 'uint', size: 4},\n    markerName: {type: PString},\n  },\n});\n\n// typedef struct {\n//   unsigned long timeStamp; /* comment creation date */\n//   MarkerId marker; /* comments for this marker number */\n//   unsigned short count; /* comment text string length */\n//   char text[]; /* comment text */\n// } Comment;\nconst AIFFCommentStruct = new BufferStruct({\n  name: 'AIFFComment',\n  endian: 'big',\n  fields: {\n    timeStamp: {type: 'uint', size: 4},\n    marker: AIFFMarkerIdField,\n    count: {type: 'uint', size: 2},\n    text: {type: 'utf8', size: (fields) => fields.count},\n  },\n});\n\nconst AIFFLoopPlayMode = {\n  NoLooping: 0,\n  ForwardLooping: 1,\n  ForwardBackwardLooping: 2,\n};\n\n// typedef struct {\n//   short playMode;\n//   MarkerId beginLoop;\n//   MarkerId endLoop;\n// } Loop;\nconst AIFFLoopStruct = new BufferStruct({\n  name: 'AIFFLoop',\n  endian: 'big',\n  fields: {\n    playMode: {type: 'int', size: 2},\n    beginLoop: AIFFMarkerIdField,\n    endLoop: AIFFMarkerIdField,\n  },\n});\n\n// typedef struct {\n//   char baseNote;\n//   char detune;\n//   char lowNote;\n//   char highNote;\n//   char lowVelocity;\n//   char highVelocity;\n//   short gain;\n//   Loop sustainLoop;\n//   Loop releaseLoop;\n// } InstrumentChunk;\nconst AIFFInstrumentStruct = new BufferStruct({\n  name: 'AIFFInstrument',\n  endian: 'big',\n  fields: {\n    baseNote: {type: 'int', size: 1},\n    detune: {type: 'int', size: 1},\n    lowNote: {type: 'int', size: 1},\n    highNote: {type: 'int', size: 1},\n    lowVelocity: {type: 'int', size: 1},\n    highVelocity: {type: 'int', size: 1},\n    gain: {type: 'int', size: 2},\n    sustainLoop: {type: AIFFLoopStruct},\n    releaseLoop: {type: AIFFLoopStruct},\n  },\n});\nconst AIFFNameChunkID = 'NAME'; /* ckID for Name Chunk */\nconst AIFFAuthorChunkID = 'AUTH'; /* ckID for Author Chunk */\nconst AIFFCopyrightChunkID = '(c) '; /* ckID for Copyright Chunk */\nconst AIFFAnnotationChunkID = 'ANNO'; /* ckID for Annotation Chunk */\n// typedef struct {\n//   ID ckID;\n//   long ckDataSize;\n//   char text[];\n// } TextChunk;\nconst AIFFTextStruct = new BufferStruct({\n  name: 'AIFFText',\n  endian: 'big',\n  fields: {\n    text: {type: 'utf8', size: (_, context) => context.dataSize},\n  },\n});\n\nconst AIFCVersion1 = 0xa2805140; /* Version 1 of AIFF-C */\n\nconst AIFCFormatStruct = new BufferStruct({\n  name: 'AIFCFormat',\n  endian: 'big',\n  fields: {\n    timestamp: {type: 'uint', size: 4},\n  },\n});\n\nfunction makeAIFFChunk(ckID, chunkData) {\n  return AIFFChunkStruct.serialize({\n    ckID,\n    ckSize: chunkData.length,\n    chunkData,\n  });\n}\n\nfunction serializeAIFF({\n  soundData,\n  numChannels,\n  sampleRate,\n  sampleSize,\n  form,\n  compressionType,\n  compressionName,\n  appl,\n}) {\n  const nsamples = Math.floor(\n    soundData.length / numChannels / (sampleSize / 8)\n  );\n  const sampleRate80Bit = Buffer.from(\n    ieeeExtended.ConvertToIeeeExtended(sampleRate)\n  );\n  DEBUG && console.log({sampleRate, sampleRate80Bit});\n\n  const formatChunk =\n    form === 'AIFC'\n      ? makeAIFFChunk(\n          'FVER',\n          AIFCFormatStruct.serialize({\n            timestamp: AIFCVersion1,\n          })\n        )\n      : null;\n\n  const commChunk = makeAIFFChunk(\n    'COMM',\n    form === 'AIFC'\n      ? AIFCCommonStruct.serialize({\n          numChannels,\n          numSampleFrames: nsamples,\n          sampleSize,\n          sampleRate: sampleRate80Bit,\n          compressionType,\n          compressionName,\n        })\n      : AIFFCommonStruct.serialize({\n          numChannels,\n          numSampleFrames: nsamples,\n          sampleSize,\n          sampleRate: sampleRate80Bit,\n        })\n  );\n\n  const soundDataChunk = makeAIFFChunk(\n    'SSND',\n    Buffer.concat([\n      AIFFSoundDataStruct.serialize(\n        {\n          offset: 0,\n          blockSize: 0,\n          soundData,\n        },\n        {\n          soundDataSize: soundData.length,\n        }\n      ),\n    ])\n  );\n\n  const applChunks =\n    form === 'AIFC' && appl\n      ? appl.map((applObj) =>\n          makeAIFFChunk(\n            'APPL',\n            Buffer.concat([\n              AIFCApplicationSpecificStruct.serialize(applObj, {\n                dataSize: applObj.data.length,\n              }),\n            ])\n          )\n        )\n      : [];\n\n  const formType = Buffer.from(form === 'AIFC' ? 'AIFC' : 'AIFF', 'utf8');\n\n  const aiffFileContents = makeAIFFChunk(\n    'FORM',\n    Buffer.concat(\n      [formType, formatChunk, commChunk, soundDataChunk, ...applChunks].filter(\n        Boolean\n      )\n    )\n  );\n\n  return aiffFileContents;\n}\n\nfunction parseAIFF(fileContents) {\n  let pos = 0;\n\n  let output = {};\n\n  const fileChunks = [];\n  while (pos < fileContents.length) {\n    DEBUG &&\n      console.error(\n        'parsing file chunk',\n        fileContents.slice(pos, pos + 4).toString('utf8'),\n        'at',\n        pos,\n        {fileContents}\n      );\n    const chunk = AIFFChunkStruct.parse(fileContents, pos);\n    chunk.startOffset = pos;\n    chunk.endOffset = AIFFChunkStruct.lastOffset;\n    fileChunks.push(chunk);\n    pos = AIFFChunkStruct.lastOffset;\n  }\n\n  DEBUG && console.log(fileChunks);\n\n  const formChunks = fileChunks.filter(\n    (fileChunk) => fileChunk.ckID === 'FORM'\n  );\n  formChunks.forEach((formChunk) => {\n    let pos = 0;\n    DEBUG && console.log('FORM chunk', formChunk);\n    formChunk.form = formChunk.chunkData.slice(0, 4).toString('utf8');\n    output.form = formChunk.form;\n    pos += 4; // skip FORM identifier\n    DEBUG && console.log({formID: formChunk.form});\n\n    const localChunks = [];\n    while (pos < formChunk.chunkData.length) {\n      DEBUG &&\n        console.error(\n          'parsing FORM local chunk',\n          formChunk.chunkData.slice(pos, pos + 4),\n          'at',\n          pos\n        );\n      const chunk = AIFFChunkStruct.parse(formChunk.chunkData, pos);\n      chunk.startOffset = pos;\n      chunk.endOffset = AIFFChunkStruct.lastOffset;\n\n      if (chunk.ckSize === 0) {\n        DEBUG &&\n          console.error(\n            'zero size chunk',\n            formChunk.chunkData.slice(pos, pos + 64)\n          );\n      }\n      switch (chunk.ckID) {\n        case 'COMM':\n          chunk.parsed =\n            formChunk.form === 'AIFC'\n              ? AIFCCommonStruct.parse(chunk.chunkData)\n              : AIFFCommonStruct.parse(chunk.chunkData);\n          chunk.parsed.sampleRate = ieeeExtended.ConvertFromIeeeExtended(\n            chunk.parsed.sampleRate\n          );\n          chunk.parsed = chunk.parsed;\n\n          output.sampleRate = chunk.parsed.sampleRate;\n          output.sampleSize = chunk.parsed.sampleSize;\n          output.numChannels = chunk.parsed.numChannels;\n          output.compressionType = chunk.parsed.compressionType;\n          output.compressionName = chunk.parsed.compressionName;\n          break;\n        case 'SSND':\n          chunk.parsed = AIFFSoundDataStruct.parse(chunk.chunkData, 0, {\n            soundDataSize:\n              chunk.ckSize - AIFF_SOUND_DATA_CHUNK_SIZE_EXCL_SOUNDDATA,\n          });\n          chunk.ssnd = chunk.parsed;\n          output.soundData = chunk.parsed.soundData;\n          break;\n        case 'MARK':\n          chunk.parsed = AIFFMarkerStruct.parse(chunk.chunkData, 0);\n          break;\n        case 'COMT':\n          chunk.parsed = AIFFCommentStruct.parse(chunk.chunkData, 0);\n          break;\n        case 'INST':\n          chunk.parsed = AIFFInstrumentStruct.parse(chunk.chunkData, 0);\n          break;\n        case AIFFNameChunkID:\n        case AIFFAuthorChunkID:\n        case AIFFCopyrightChunkID:\n        case AIFFAnnotationChunkID:\n          chunk.parsed = AIFFTextStruct.parse(chunk.chunkData, 0, {\n            dataSize: chunk.ckSize,\n          });\n          break;\n        case 'APPL':\n          chunk.parsed = AIFCApplicationSpecificStruct.parse(\n            chunk.chunkData,\n            0,\n            {\n              dataSize: chunk.ckSize - AIFC_APPL_CHUNK_SIZE_EXCL_DATA,\n            }\n          );\n          chunk.appl = chunk.parsed;\n          output.appl = output.appl || [];\n          output.appl.push(chunk.parsed);\n          break;\n        case 'AIFC':\n          chunk.parsed = AIFCFormatStruct.parse(chunk.chunkData);\n          chunk.format = chunk.parsed;\n          break;\n        case 'FVER':\n          chunk.parsed = AIFCFormatStruct.parse(chunk.chunkData);\n          chunk.fver = chunk.parsed;\n          break;\n        default:\n          DEBUG && console.error('unknown chunk type', chunk.ckID);\n      }\n\n      DEBUG && console.log('local chunk', chunk);\n\n      localChunks.push(chunk);\n      pos = AIFFChunkStruct.lastOffset;\n    }\n    formChunk.localChunks = localChunks;\n  });\n  output.fileChunks = fileChunks;\n  output.formChunks = formChunks;\n  return output;\n}\n\nmodule.exports = {\n  serialize: serializeAIFF,\n  parse: parseAIFF,\n  PString,\n  AIFFLoopPlayMode,\n};\n","import { StrictMode } from \"react\";\nimport ReactDOM from \"react-dom\";\n\nimport App from \"./App\";\n\nconst rootElement = document.getElementById(\"root\");\nReactDOM.render(\n  <StrictMode>\n    <App />\n  </StrictMode>,\n  rootElement\n);\n","// https://en.cppreference.com/w/cpp/numeric/math/ldexp\nconst ldexp = (x, exp) => x * Math.pow(2, exp);\n\n// from https://raw.githubusercontent.com/locutusjs/locutus/master/src/c/math/frexp.js\n// license: https://github.com/locutusjs/locutus/blob/master/LICENSE\nfunction frexp(arg) {\n  arg = Number(arg);\n\n  const result = [arg, 0];\n\n  if (arg !== 0 && Number.isFinite(arg)) {\n    const absArg = Math.abs(arg);\n    // Math.log2 was introduced in ES2015, use it when available\n    const log2 =\n      Math.log2 ||\n      function log2(n) {\n        return Math.log(n) * Math.LOG2E;\n      };\n    let exp = Math.max(-1023, Math.floor(log2(absArg)) + 1);\n    let x = absArg * Math.pow(2, -exp);\n\n    // These while loops compensate for rounding errors that sometimes occur because of ECMAScript's Math.log2's undefined precision\n    // and also works around the issue of Math.pow(2, -exp) === Infinity when exp <= -1024\n    while (x < 0.5) {\n      x *= 2;\n      exp--;\n    }\n    while (x >= 1) {\n      x *= 0.5;\n      exp++;\n    }\n\n    if (arg < 0) {\n      x = -x;\n    }\n    result[0] = x;\n    result[1] = exp;\n  }\n  return result;\n}\n\n// this IEEE extended stuff comes from http://groovit.disjunkt.com/analog/specifs/ieee.c\n\n/*\n * C O N V E R T   T O   I E E E   E X T E N D E D\n */\n\nconst FloatToUnsigned = (f) => f - 2147483648.0 + 2147483647 + 1;\n\nfunction ConvertToIeeeExtended(/*double*/ num) {\n  let /*char**/ bytes = new Array(10).fill(0);\n  let /*int*/ sign;\n  let /*int*/ expon;\n  let /*double*/ fMant, fsMant;\n  let /*unsigned long*/ hiMant, loMant;\n\n  if (num < 0) {\n    sign = 0x8000;\n    num *= -1;\n  } else {\n    sign = 0;\n  }\n\n  if (num == 0) {\n    expon = 0;\n    hiMant = 0;\n    loMant = 0;\n  } else {\n    const frexpRes = frexp(num);\n    fMant = frexpRes[0];\n    expon = frexpRes[1];\n\n    if (expon > 16384 || !(fMant < 1)) {\n      /* Infinity or NaN */\n      expon = sign | 0x7fff;\n      hiMant = 0;\n      loMant = 0; /* infinity */\n    } else {\n      /* Finite */\n      expon += 16382;\n      if (expon < 0) {\n        /* denormalized */\n        fMant = ldexp(fMant, expon);\n        expon = 0;\n      }\n      expon |= sign;\n      fMant = ldexp(fMant, 32);\n      fsMant = Math.floor(fMant);\n      hiMant = FloatToUnsigned(fsMant);\n      fMant = ldexp(fMant - fsMant, 32);\n      fsMant = Math.floor(fMant);\n      loMant = FloatToUnsigned(fsMant);\n    }\n  }\n\n  bytes[0] = expon >> 8;\n  bytes[1] = expon;\n  bytes[2] = hiMant >> 24;\n  bytes[3] = hiMant >> 16;\n  bytes[4] = hiMant >> 8;\n  bytes[5] = hiMant;\n  bytes[6] = loMant >> 24;\n  bytes[7] = loMant >> 16;\n  bytes[8] = loMant >> 8;\n  bytes[9] = loMant;\n\n  return bytes;\n}\n\n/*\n * C O N V E R T   F R O M   I E E E   E X T E N D E D\n */\n\nconst UnsignedToFloat = (u) => ((u - 2147483647) | 0) - 1 + 2147483648.0;\n\n/****************************************************************\n * Extended precision IEEE floating-point conversion routine.\n ****************************************************************/\n\nfunction ConvertFromIeeeExtended(/*unsigned char**/ bytes /* LCN */) {\n  let /*double*/ f;\n  let /*int*/ expon;\n  let /*unsigned long*/ hiMant, loMant;\n\n  expon = ((bytes[0] & 0x7f) << 8) | (bytes[1] & 0xff);\n  hiMant =\n    ((bytes[2] & 0xff) << 24) |\n    ((bytes[3] & 0xff) << 16) |\n    ((bytes[4] & 0xff) << 8) |\n    (bytes[5] & 0xff);\n  loMant =\n    ((bytes[6] & 0xff) << 24) |\n    ((bytes[7] & 0xff) << 16) |\n    ((bytes[8] & 0xff) << 8) |\n    (bytes[9] & 0xff);\n\n  if (expon == 0 && hiMant == 0 && loMant == 0) {\n    f = 0;\n  } else {\n    if (expon == 0x7fff) {\n      /* Infinity or NaN */\n      f = Infinity;\n    } else {\n      expon -= 16383;\n      f = ldexp(UnsignedToFloat(hiMant), (expon -= 31));\n      f += ldexp(UnsignedToFloat(loMant), (expon -= 32));\n    }\n  }\n\n  if (bytes[0] & 0x80) return -f;\n  else return f;\n}\n\nmodule.exports = {\n  ConvertFromIeeeExtended,\n  ConvertToIeeeExtended\n};\n","const DEBUG = false;\n\nfunction nullthrows(value, message) {\n  if (value == null) {\n    throw new Error(\"unexpected null\" + (message ? \": \" + message : \"\"));\n  }\n  return value;\n}\n\nfunction nanthrows(value, message) {\n  if (isNaN(value)) {\n    throw new Error(\"unexpected NaN\" + (message ? \": \" + message : \"\"));\n  }\n  return value;\n}\n\nconst FieldTypesToBufferMethods = {\n  uint: \"UInt\",\n  int: \"Int\",\n  float: \"Float\",\n  double: \"Double\",\n  bigint: \"BigInt\",\n  biguint: \"BigUint\",\n  char: \"UInt\"\n};\n\nconst BytesTypes = new Set([\"bytes\", \"utf8\"]);\n\nfunction getBufferMethodName(type, size, endian) {\n  return `${FieldTypesToBufferMethods[type]}${size * 8}${\n    size == 1 ? \"\" : endian == \"big\" ? \"BE\" : \"LE\"\n  }`;\n}\n\nfunction getAlignedSize(size, alignment) {\n  return Math.ceil(size / alignment) * alignment;\n}\n\nfunction getAlignedSizeForField(field, size) {\n  return field.align != null\n    ? getAlignedSize(nanthrows(size), nanthrows(field.align))\n    : nanthrows(size);\n}\n\n/*\n  schema: an object mapping field names to a definition object.\n  definitions can have the following properties: \n  type: how to interpret the binary data. options:\n    uint -> number\n    int -> number\n    float -> number\n    double -> number\n    bigint -> BigInt\n    biguint -> BigInt\n    char -> number\n    bytes -> Buffer\n    utf8 -> string\n    BufferStructBase | BufferStruct | BufferStructUnion -> nested object\n  size: serialized field size in bytes\n  endian: endianness used when interpreting binary data\n  default: default value used when serializing if value not provided\n  size: size of field in bytes. can be fixed size or function determining size\n  arrayElements: treat this field as an array. function returning number of items\n  align: pad the field to a multiple of this number\n */\n\nclass BufferStructBase {\n  constructor(schema) {\n    this.schema = schema;\n    this.lastOffset = 0;\n  }\n\n  parse(buffer, startOffset, contextData = null) {\n    // should return value for this field and update this.lastOffset\n  }\n\n  serialize(data, contextData = null) {\n    // should return buffer of serialized data\n  }\n\n  getStaticSize() {\n    throw new Error(\n      \"getStaticSize not implemented on: \" + this.constructor.name\n    );\n  }\n\n  getName() {\n    return this.schema.name || this.constructor.name;\n  }\n}\n\nclass BufferStruct extends BufferStructBase {\n  parse(buffer, startOffset, contextData = null) {\n    const partialResult = {};\n    let offset = startOffset || 0;\n    Object.keys(this.schema.fields).forEach((fieldName) => {\n      const { field, endian, size, type } = this._getFieldConfig(\n        fieldName,\n        partialResult,\n        contextData\n      );\n\n      const parse = BytesTypes.has(type)\n        ? (buffer, startOffset) => {\n            if (size == null) {\n              throw new Error(\n                `can't parse field of type 'bytes' without predetermined size`\n              );\n            }\n            if (buffer.length < startOffset + size) {\n              throw new Error(\n                `tried to read ${size} bytes but only ${\n                  buffer.length - startOffset\n                } remaining for field ${fieldName} on ${this.getName()}`\n              );\n            }\n            const valueAsBuffer = buffer.slice(startOffset, startOffset + size);\n            let value = valueAsBuffer;\n            if (type === \"utf8\") {\n              value = valueAsBuffer.toString(\"utf8\");\n            }\n            return { value, parsedSize: size };\n          }\n        : type instanceof BufferStructBase\n        ? (buffer, startOffset) => {\n            // console.log('parsing', type.getName(), 'at', startOffset);\n            const value = type.parse(buffer, startOffset, contextData);\n            // use static size where determined (eg. in case of union)\n            const parsedSize =\n              size != null ? size : type.lastOffset - startOffset; // change in offset after parsing\n            // console.log({value, parsedSize});\n\n            return { value, parsedSize };\n          }\n        : (buffer, startOffset) => {\n            const methodName = `read${getBufferMethodName(type, size, endian)}`;\n\n            const value = buffer[methodName](startOffset);\n            if (this.schema.traceReads) {\n              console.log(methodName, {\n                fieldName,\n                type,\n                size,\n                endian,\n                startOffset,\n                value\n              });\n            }\n\n            return { value, parsedSize: size };\n          };\n\n      // the ability to provide predetermined size, as well as define alignment, means we need to account for either of these\n      // sources of padding when advancing the point we are reading in the buffer\n      const parseWithAlignment = (buffer, startOffset) => {\n        const { value, parsedSize } = parse(buffer, nanthrows(startOffset));\n\n        if (size != null && parsedSize > size) {\n          throw new Error(\n            `parsed size ${parsedSize} larger than predetermined size ${size} for field ${fieldName} on ${this.getName()}`\n          );\n        }\n\n        // when field is aligned we must make sure to advance by aligned size\n        // additionally, if a predetermined size is set, we should use that size instead (in case of padding)\n        // we have already asserted above that the parsed size is not larger than the predetermined size\n        let parsedSizeWithAlignment = getAlignedSizeForField(\n          field,\n          size != null ? size : parsedSize\n        );\n\n        if (size != null) {\n          const alignedExpectedSize = getAlignedSizeForField(field, size);\n\n          if (parsedSizeWithAlignment > alignedExpectedSize) {\n            throw new Error(\n              `aligned parsed size ${parsedSizeWithAlignment} larger than aligned predetermined size ${alignedExpectedSize} for field ${fieldName} on ${this.getName()}`\n            );\n          }\n        }\n\n        return { value, consumedSize: nanthrows(parsedSizeWithAlignment) };\n      };\n\n      // try {\n      if (field.arrayElements) {\n        // array field\n        const count =\n          typeof field.arrayElements === \"function\"\n            ? field.arrayElements(partialResult, contextData)\n            : field.arrayElements;\n        const array = new Array(count);\n\n        for (var i = 0; i < count; ++i) {\n          // console.log('getting array el', i, 'of', count, 'at', offset);\n          const { value, consumedSize } = parseWithAlignment(buffer, offset);\n\n          offset += nanthrows(consumedSize);\n          array[i] = value;\n        }\n\n        partialResult[fieldName] = array;\n      } else {\n        // non-array field\n        const { value, consumedSize } = parseWithAlignment(buffer, offset);\n        offset += nanthrows(consumedSize);\n        partialResult[fieldName] = value;\n      }\n      // } catch (error) {\n      //   throw new Error(\n      //     `failed parsing field ${fieldName} on ${this.getName()}: ${error}`\n      //   );\n      // }\n    });\n    if (isNaN(offset)) {\n      throw new Error(`invalid offset while parsing ${this.getName()}`);\n    }\n    this.lastOffset = offset;\n    return partialResult;\n  }\n\n  _getFieldConfig(fieldName, partialFieldData, contextData) {\n    const field = nullthrows(\n      this.schema.fields[fieldName],\n      `${fieldName} schema is missing`\n    );\n    const endian = field.endian || this.schema.endian || \"little\";\n    const type = nullthrows(field.type, `${fieldName} type`);\n    if (\n      !(\n        type instanceof BufferStructBase ||\n        type instanceof BufferStructUnion ||\n        type in FieldTypesToBufferMethods ||\n        BytesTypes.has(type)\n      )\n    ) {\n      throw new Error(`unsupported type ${type} in ${fieldName}`);\n    }\n\n    // use statically defined size if we've got it\n    let size =\n      typeof field.size === \"function\"\n        ? field.size(partialFieldData, contextData)\n        : field.size;\n    if (BytesTypes.has(type)) {\n      // allow size to be dynamic\n    } else if (type instanceof BufferStructBase) {\n      // allow size to be dynamic\n    } else if (type instanceof BufferStructUnion) {\n      // size will be statically known (asserted in BufferStructUnion)\n      size = type.size;\n    } else {\n      // size must be statically known\n      size = nullthrows(size, `${fieldName} size`);\n    }\n\n    let actualType = type;\n    // replace union type with actual type\n    if (type instanceof BufferStructUnion) {\n      actualType = type.selectMember(partialFieldData, contextData);\n      if (actualType == null) {\n        throw new Error(\n          `failed to refine union type in field ${fieldName} on ${this.getName()}`\n        );\n      }\n    }\n\n    return { field, endian, size, type: actualType };\n  }\n\n  serialize(data, contextData = null) {\n    if (!data) {\n      throw new Error(\n        `missing argument 'data' when serializing ${this.getName()}`\n      );\n    }\n    const parts = [];\n    Object.keys(this.schema.fields).forEach((fieldName) => {\n      const { field, endian, size, type } = this._getFieldConfig(\n        fieldName,\n        data,\n        contextData\n      );\n\n      let value;\n      if (!(fieldName in data)) {\n        if (\"default\" in field) {\n          value = field.default;\n        } else {\n          throw new Error(\n            `missing field ${fieldName} when serializing ${this.getName()}`\n          );\n        }\n      }\n      value = data[fieldName];\n\n      const serialize = BytesTypes.has(type)\n        ? (value) => {\n            let valueAsBuffer = value;\n            if (type === \"utf8\") {\n              valueAsBuffer = Buffer.from(value, \"utf8\");\n            }\n\n            const dynSize = size == null ? valueAsBuffer.length : size;\n            const partBuffer = Buffer.alloc(dynSize);\n            valueAsBuffer.copy(partBuffer, 0, 0, dynSize);\n\n            return partBuffer;\n          }\n        : type instanceof BufferStructBase\n        ? (value) => type.serialize(value, contextData)\n        : (value) => {\n            const methodName = `write${getBufferMethodName(\n              type,\n              size,\n              endian\n            )}`;\n\n            const partBuffer = Buffer.alloc(size);\n            partBuffer[methodName](value);\n            if (this.schema.traceWrites) {\n              console.log(methodName, {\n                fieldName,\n                type,\n                size,\n                endian,\n                value\n              });\n            }\n\n            return partBuffer;\n          };\n\n      const serializeWithAlignment = (value) => {\n        const partBuffer = serialize(value);\n        const serializedSize = partBuffer.length;\n        if (size != null && serializedSize > size) {\n          throw new Error(\n            `serialized size ${serializedSize} larger than predetermined size ${size} for field ${fieldName} on ${this.getName()}`\n          );\n        }\n\n        let maybeAlignedPartBuffer = partBuffer;\n        if (field.align != null) {\n          const alignedSerializedSize = getAlignedSize(\n            serializedSize,\n            field.align\n          );\n          const alignedExpectedSize = getAlignedSize(size, field.align);\n          if (alignedSerializedSize > alignedExpectedSize)\n            throw new Error(\n              `serialized aligned size ${\n                maybeAlignedPartBuffer.length\n              } larger than predetermined size (aligned) ${alignedExpectedSize} for field ${fieldName} on ${this.getName()}`\n            );\n\n          const partBufferAligned = Buffer.alloc(alignedSerializedSize);\n          partBuffer.copy(partBufferAligned);\n          maybeAlignedPartBuffer = partBufferAligned;\n        }\n\n        return maybeAlignedPartBuffer;\n      };\n\n      // try {\n      if (field.arrayElements) {\n        for (var i = 0; i < value.length; ++i) {\n          const part = serializeWithAlignment(value[i]);\n          parts.push(part);\n        }\n      } else {\n        const part = serializeWithAlignment(value);\n        parts.push(part);\n      }\n      // } catch (error) {\n      //   const extra = DEBUG ? `${error.stack} \\nrethrown stack:` : '';\n      //   throw new Error(\n      //     `failed serializing field ${fieldName}: ${error} ${extra}`\n      //   );\n      // }\n    });\n\n    return Buffer.concat(parts);\n  }\n\n  _staticSize = null;\n  getStaticSize() {\n    const prevSize = this._staticSize;\n    if (prevSize != null) {\n      return prevSize;\n    } else {\n      let size = 0;\n      for (const field of Object.values(this.schema.fields)) {\n        if (typeof field.size != \"number\") {\n          throw new Error(\n            \"cannot get static size of struct: \" + this.getName()\n          );\n        }\n        const alignedFieldSize = getAlignedSizeForField(field, field.size);\n        size += alignedFieldSize;\n      }\n      this._staticSize = size;\n      return size;\n    }\n  }\n}\n\n// simulates c struct union functionality, using the provided selectMember function\n// to choose which union member (BufferStruct) to interpret data as based on previously parsed fields.\n// requires that all union members have statically determinable size (eg. no arrays or dynamically sized bytes fields allowed)\n// when serializing, the maximum member size will be used\nclass BufferStructUnion {\n  constructor({ members, selectMember }) {\n    this.selectMember = selectMember;\n    this.members = members;\n    this.size = Math.max(...members.map((m) => m.getStaticSize()));\n  }\n}\n\nmodule.exports = {\n  BufferStruct,\n  BufferStructBase,\n  BufferStructUnion\n};\n","import './styles.css';\nimport * as AIFF from './aiff';\nimport {useState, useCallback} from 'react';\n\nfunction readFile(file) {\n  return new Promise((resolve, reject) => {\n    const reader = new FileReader();\n    reader.readAsArrayBuffer(file);\n    reader.addEventListener('load', () => {\n      resolve(reader.result);\n    });\n    reader.addEventListener('error', () => {\n      reject(reader.error);\n    });\n  });\n}\n\nconst boxStyle = {\n  border: 'solid 1px black',\n};\nconst textStyle = {\n  margin: '8px 8px',\n  wordWrap: 'break-word',\n};\n\nfunction DisplayObject({object}) {\n  return (\n    <div style={{...boxStyle, margin: '8px 0px'}}>\n      {Object.keys(object).map((key) => {\n        if (object[key] && typeof object[key] === 'object') {\n          if (typeof object[key].length === 'number') {\n            return (\n              <div key={key} style={textStyle}>\n                {key}:{' '}\n                {typeof object[key].length === 'number' ? (\n                  `Buffer {size: ${object[key].length}}`\n                ) : (\n                  <DisplayObject object={object[key]} />\n                )}\n              </div>\n            );\n          }\n          return (\n            <div key={key} style={textStyle}>\n              {key}: <DisplayObject object={object[key]} />\n            </div>\n          );\n        }\n        return (\n          <div key={key} style={textStyle}>\n            {key}: {JSON.stringify(object[key])}\n          </div>\n        );\n      })}\n    </div>\n  );\n}\n\nfunction AiffChunk({chunk}) {\n  const {ckID, ckSize, localChunks} = chunk;\n  let chunkSpecificData = chunk.parsed;\n  if (ckID === 'FORM') {\n    chunkSpecificData = {formType: chunk.form};\n  }\n\n  return (\n    <div style={{...boxStyle, margin: '8px 0px'}}>\n      <div style={textStyle}>chunk ID: {ckID}</div>\n      <div style={textStyle}>chunk size: {ckSize}</div>\n      {chunkSpecificData && (\n        <div style={textStyle}>\n          {ckID} fields:{' '}\n          {typeof chunkSpecificData === 'object' ? (\n            <DisplayObject object={chunkSpecificData} />\n          ) : (\n            JSON.stringify(chunkSpecificData)\n          )}\n        </div>\n      )}\n      {localChunks && (\n        <div style={textStyle}>\n          local chunks:\n          {localChunks.map((lchunk, i) => (\n            <AiffChunk key={i} chunk={lchunk} />\n          ))}\n        </div>\n      )}\n      <div style={{...textStyle, fontSize: '0.8em', color: '#777'}}>\n        end {ckID} chunk\n      </div>\n    </div>\n  );\n}\n\nexport default function App() {\n  const [aiff, setAiff] = useState(null);\n  const [error, setError] = useState(null);\n\n  const handleFiles = useCallback(async function handleFiles(e) {\n    const fileList =\n      e.currentTarget.files; /* now you can work with the file list */\n\n    const data = await readFile(fileList[0]);\n    try {\n      setAiff(AIFF.parse(new Buffer(data)));\n    } catch (err) {\n      setError(err);\n    }\n  }, []);\n\n  return (\n    <div className=\"App\">\n      <h1>AIFF explorer</h1>\n      <div>\n        <p>This tool visualizes the chunks in an AIFF file.</p>\n        <input type=\"file\" id=\"input\" onChange={handleFiles} />\n      </div>\n\n      {error && <pre>{error.toString() + '\\n' + error.stack}</pre>}\n      {aiff &&\n        aiff.fileChunks.map((chunk, i) => <AiffChunk key={i} chunk={chunk} />)}\n    </div>\n  );\n}\n"],"sourceRoot":""}