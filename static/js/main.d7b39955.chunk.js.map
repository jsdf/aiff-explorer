{"version":3,"sources":["App.js","aiff.js","Details.js","index.js","ieeeextended.js","bufferstruct.js"],"names":["readFile","file","Promise","resolve","reject","reader","FileReader","readAsArrayBuffer","addEventListener","result","error","boxStyle","border","textStyle","margin","wordWrap","textStyleFlushLeft","DisplayObject","object","style","Object","keys","map","key","value","Array","isArray","v","i","length","JSON","stringify","AiffChunk","chunk","ckID","ckSize","localChunks","chunkSpecificData","parsed","formType","form","startOpen","summary","summaryStyle","width","cursor","fontWeight","lchunk","fontSize","color","App","useState","aiff","setAiff","setError","handleFiles","useCallback","e","a","fileList","currentTarget","files","data","AIFF","Buffer","err","className","type","id","onChange","height","display","padding","toString","fileChunks","ieeeExtended","require","BufferStruct","BufferStructBase","BufferStructUnion","PString","constructor","super","name","parse","buffer","startOffset","contextData","readUInt8","str","slice","consumed","size","alignment","Math","ceil","this","lastOffset","serialize","Error","getName","parts","from","push","alloc","concat","AIFFChunkStruct","endian","fields","chunkData","align","AIFFCommonStruct","numChannels","numSampleFrames","sampleSize","sampleRate","AIFCCommonStruct","compressionType","compressionName","AIFCApplicationSpecificStruct","applicationSignature","context","dataSize","AIFFSoundDataStruct","offset","blockSize","soundData","soundDataSize","AIFFMarkerIdField","AIFFMarkerStruct","position","markerName","AIFFMarkerChunkStruct","numMarkers","markers","arrayElements","AIFFCommentStruct","timeStamp","marker","count","text","AIFFLoopStruct","playMode","beginLoop","endLoop","AIFFInstrumentStruct","baseNote","detune","lowNote","highNote","lowVelocity","highVelocity","gain","sustainLoop","releaseLoop","AIFFTextStruct","_","AIFCFormatStruct","timestamp","makeAIFFChunk","module","exports","appl","nsamples","floor","sampleRate80Bit","ConvertToIeeeExtended","formatChunk","commChunk","soundDataChunk","applChunks","applObj","filter","Boolean","fileContents","pos","output","endOffset","formChunks","fileChunk","forEach","formChunk","ConvertFromIeeeExtended","ssnd","format","fver","AIFFLoopPlayMode","NoLooping","ForwardLooping","ForwardBackwardLooping","Details","children","React","open","setOpen","onToggle","preventDefault","stopPropagation","onClick","rootElement","document","getElementById","ReactDOM","render","ldexp","x","exp","pow","FloatToUnsigned","f","UnsignedToFloat","u","bytes","expon","hiMant","loMant","Infinity","num","sign","fMant","fsMant","fill","frexpRes","arg","Number","isFinite","absArg","abs","log2","n","log","LOG2E","max","frexp","nullthrows","message","nanthrows","isNaN","FieldTypesToBufferMethods","uint","int","float","double","bigint","biguint","char","BytesTypes","Set","getBufferMethodName","getAlignedSize","getAlignedSizeForField","field","schema","getStaticSize","members","selectMember","m","_staticSize","partialResult","fieldName","_getFieldConfig","has","valueAsBuffer","parsedSize","methodName","traceReads","console","parseWithAlignment","parsedSizeWithAlignment","alignedExpectedSize","consumedSize","array","partialFieldData","actualType","default","dynSize","partBuffer","copy","traceWrites","serializeWithAlignment","serializedSize","maybeAlignedPartBuffer","alignedSerializedSize","partBufferAligned","part","prevSize","values"],"mappings":"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","file":"static/js/main.d7b39955.chunk.js","sourcesContent":["import './styles.css';\nimport * as AIFF from './aiff';\nimport {useState, useCallback} from 'react';\nimport Details from './Details';\n\nfunction readFile(file) {\n  return new Promise((resolve, reject) => {\n    const reader = new FileReader();\n    reader.readAsArrayBuffer(file);\n    reader.addEventListener('load', () => {\n      resolve(reader.result);\n    });\n    reader.addEventListener('error', () => {\n      reject(reader.error);\n    });\n  });\n}\n\nconst boxStyle = {\n  border: 'solid 1px black',\n};\nconst textStyle = {\n  margin: '8px 8px',\n  wordWrap: 'break-word',\n};\nconst textStyleFlushLeft = {\n  margin: '8px 0',\n  wordWrap: 'break-word',\n};\n\nfunction DisplayObject({object}) {\n  return (\n    <div style={{...boxStyle, margin: '8px 0px'}}>\n      {Object.keys(object).map((key) => {\n        const value = object[key];\n        if (value && typeof value === 'object') {\n          if (Array.isArray(value)) {\n            return (\n              <div key={key} style={textStyle}>\n                {key}:{' '}\n                {value.map((v, i) => (\n                  <DisplayObject key={i} object={v} />\n                ))}\n              </div>\n            );\n          }\n          if (typeof value.length === 'number') {\n            return (\n              <div key={key} style={textStyle}>\n                {key}: {`Buffer {size: ${value.length}}`}\n              </div>\n            );\n          }\n          return (\n            <div key={key} style={textStyle}>\n              {key}: <DisplayObject object={value} />\n            </div>\n          );\n        }\n        return (\n          <div key={key} style={textStyle}>\n            {key}: {JSON.stringify(value)}\n          </div>\n        );\n      })}\n    </div>\n  );\n}\n\nfunction AiffChunk({chunk}) {\n  const {ckID, ckSize, localChunks} = chunk;\n  let chunkSpecificData = chunk.parsed;\n  if (ckID === 'FORM') {\n    chunkSpecificData = {formType: chunk.form};\n  }\n\n  // <summary style={{...textStyle, fontWeight: 'bold'}}>{ckID}</summary>\n  return (\n    <div style={{...boxStyle, margin: '8px 0px'}}>\n      <Details\n        style={textStyle}\n        startOpen\n        summary={ckID}\n        summaryStyle={{\n          width: '100%',\n          cursor: 'pointer',\n          fontWeight: 'bold',\n        }}\n      >\n        <div style={textStyleFlushLeft}>chunk size: {ckSize}</div>\n        {chunkSpecificData && (\n          <div style={textStyleFlushLeft}>\n            {ckID} fields:{' '}\n            {typeof chunkSpecificData === 'object' ? (\n              <DisplayObject object={chunkSpecificData} />\n            ) : (\n              JSON.stringify(chunkSpecificData)\n            )}\n          </div>\n        )}\n        {localChunks && (\n          <div style={textStyleFlushLeft}>\n            local chunks:\n            {localChunks.map((lchunk, i) => (\n              <AiffChunk key={i} chunk={lchunk} />\n            ))}\n          </div>\n        )}\n        <div style={{...textStyleFlushLeft, fontSize: '0.8em', color: '#777'}}>\n          end {ckID} chunk\n        </div>\n      </Details>\n    </div>\n  );\n}\n\nexport default function App() {\n  const [aiff, setAiff] = useState(null);\n  const [error, setError] = useState(null);\n\n  const handleFiles = useCallback(async function handleFiles(e) {\n    const fileList =\n      e.currentTarget.files; /* now you can work with the file list */\n\n    const data = await readFile(fileList[0]);\n    try {\n      setAiff(AIFF.parse(new Buffer(data)));\n      setError(null);\n    } catch (err) {\n      setAiff(null);\n      setError(err);\n    }\n  }, []);\n\n  return (\n    <div className=\"App\">\n      <h1>AIFF explorer</h1>\n      <div>\n        <p>This tool visualizes the chunks in an AIFF file.</p>\n        <input\n          type=\"file\"\n          id=\"input\"\n          onChange={handleFiles}\n          style={{\n            cursor: 'pointer',\n            height: aiff ? null : 300,\n            width: aiff ? null : 600,\n            display: aiff ? null : 'block',\n            border: 'dashed #aaa 1px',\n            padding: 16,\n          }}\n        />\n      </div>\n\n      {error && (\n        <p>\n          Error: this is probably not a valid AIFF file ({error.toString()})\n        </p>\n      )}\n      {aiff &&\n        aiff.fileChunks.map((chunk, i) => <AiffChunk key={i} chunk={chunk} />)}\n      {!(aiff || error) && (\n        <div>\n          <p>\n            Select (or drag and drop) an .aif, .aiff, or .aifc file to begin.\n          </p>\n        </div>\n      )}\n    </div>\n  );\n}\n","const ieeeExtended = require('./ieeeextended');\nconst {\n  BufferStruct,\n  BufferStructUnion,\n  BufferStructBase,\n} = require('./bufferstruct');\n\nconst DEBUG = false;\n\nfunction getAlignedSize(size, alignment) {\n  return Math.ceil(size / alignment) * alignment;\n}\n\n// pascal-style string\nclass PStringParser extends BufferStructBase {\n  constructor() {\n    super({name: 'PString'});\n  }\n  parse(buffer, startOffset, contextData = null) {\n    const length = buffer.readUInt8(startOffset);\n\n    const str = buffer\n      .slice(startOffset + 1, startOffset + 1 + length)\n      .toString('utf8');\n\n    const consumed = getAlignedSize(1 + length, 2); // pad to multiple of 2\n\n    this.lastOffset = startOffset + consumed;\n    return str;\n  }\n\n  serialize(data, contextData = null) {\n    if (!data) {\n      throw new Error(\n        `missing argument 'data' when serializing ${this.getName()}`\n      );\n    }\n\n    const parts = [Buffer.from([data.length]), Buffer.from(data)];\n\n    // pad to even size\n    if ((1 + data.length) % 2 === 1) {\n      parts.push(Buffer.alloc(1));\n    }\n\n    return Buffer.concat(parts);\n  }\n}\n\nconst PString = new PStringParser();\n\n// AIFF stuff\n// http://paulbourke.net/dataformats/audio/\n// http://www-mmsp.ece.mcgill.ca/Documents/AudioFormats/AIFF/Docs/AIFF-1.3.pdf\n// http://www-mmsp.ece.mcgill.ca/Documents/AudioFormats/AIFF/Docs/AIFF-C.9.26.91.pdf\nconst AIFFChunkStruct = new BufferStruct({\n  name: 'AIFFChunk',\n  endian: 'big',\n  fields: {\n    ckID: {type: 'utf8', size: 4},\n    ckSize: {type: 'int', size: 4},\n    chunkData: {type: 'bytes', align: 2, size: (fields) => fields.ckSize},\n  },\n});\n\n// short numChannels;\n// unsigned long numSampleFrames;\n// short sampleSize;\n// extended sampleRate;\nconst AIFFCommonStruct = new BufferStruct({\n  name: 'AIFFCommon',\n  endian: 'big',\n  fields: {\n    numChannels: {type: 'int', size: 2},\n    numSampleFrames: {type: 'uint', size: 4},\n    sampleSize: {type: 'int', size: 2},\n    sampleRate: {type: 'bytes', size: 10},\n  },\n});\n\n// short numChannels; /* # audio channels */\n// unsigned long numSampleFrames; /* # sample frames = samples/channel */\n// short sampleSize; /* # bits/sample */\n// extended sampleRate; /* sample_frames/sec */\n// ID compressionType; /* compression type ID code */\n// pstring compressionName; /* human-readable compression type name */\nconst AIFCCommonStruct = new BufferStruct({\n  name: 'AIFCCommon',\n  endian: 'big',\n  fields: {\n    numChannels: {type: 'int', size: 2},\n    numSampleFrames: {type: 'uint', size: 4},\n    sampleSize: {type: 'int', size: 2},\n    sampleRate: {type: 'bytes', size: 10},\n    compressionType: {type: 'utf8', size: 4},\n    compressionName: {type: PString},\n  },\n});\n\n// #define ApplicationSpecificID 'APPL' /* ckID for Application Specific Chunk */\n// typedef struct {\n// ID ckID; /* 'APPL' */\n// long ckDataSize;\n// OSType applicationSignature;\n// char data[];\n// } ApplicationSpecificChunk;\nconst AIFC_APPL_CHUNK_SIZE_EXCL_DATA = 4; // sum of fixed-size fields\nconst AIFCApplicationSpecificStruct = new BufferStruct({\n  name: 'AIFCApplicationSpecific',\n  endian: 'big',\n  fields: {\n    applicationSignature: {type: 'utf8', size: 4},\n    data: {\n      type: 'bytes',\n      size: (fields, context) => context.dataSize,\n    },\n  },\n});\n\n// unsigned long offset;\n// unsigned long blockSize;\nconst AIFF_SOUND_DATA_CHUNK_SIZE_EXCL_SOUNDDATA = 8; // sum of fixed-size fields\nconst AIFFSoundDataStruct = new BufferStruct({\n  name: 'AIFFSoundData',\n  endian: 'big',\n  fields: {\n    offset: {type: 'uint', size: 4},\n    blockSize: {type: 'uint', size: 4},\n    soundData: {\n      type: 'bytes',\n      size: (fields, context) => context.soundDataSize,\n    },\n  },\n});\n\n// typedef short MarkerId;\nconst AIFFMarkerIdField = {type: 'int', size: 2};\n//   typedef struct {\n//   MarkerId id; /* must be > 0 */\n//   unsigned long position; /* sample frame number */\n//   pstring markerName;\n// } Marker;\nconst AIFFMarkerStruct = new BufferStruct({\n  name: 'AIFFMarker',\n  endian: 'big',\n  fields: {\n    id: AIFFMarkerIdField,\n    position: {type: 'uint', size: 4},\n    markerName: {type: PString},\n  },\n});\n\n// typedef struct {\n//   ID ckID;\n//   long ckSize;\n//   unsigned short numMarkers;\n//   Marker Markers[];\n// } MarkerChunk;\nconst AIFFMarkerChunkStruct = new BufferStruct({\n  name: 'AIFFMarkerChunk',\n  endian: 'big',\n  fields: {\n    numMarkers: {type: 'uint', size: 2},\n    markers: {\n      type: AIFFMarkerStruct,\n      arrayElements: (fields) => fields.numMarkers,\n    },\n  },\n});\n\n// typedef struct {\n//   unsigned long timeStamp; /* comment creation date */\n//   MarkerId marker; /* comments for this marker number */\n//   unsigned short count; /* comment text string length */\n//   char text[]; /* comment text */\n// } Comment;\nconst AIFFCommentStruct = new BufferStruct({\n  name: 'AIFFComment',\n  endian: 'big',\n  fields: {\n    timeStamp: {type: 'uint', size: 4},\n    marker: AIFFMarkerIdField,\n    count: {type: 'uint', size: 2},\n    text: {type: 'utf8', size: (fields) => fields.count},\n  },\n});\n\nconst AIFFLoopPlayMode = {\n  NoLooping: 0,\n  ForwardLooping: 1,\n  ForwardBackwardLooping: 2,\n};\n\n// typedef struct {\n//   short playMode;\n//   MarkerId beginLoop;\n//   MarkerId endLoop;\n// } Loop;\nconst AIFFLoopStruct = new BufferStruct({\n  name: 'AIFFLoop',\n  endian: 'big',\n  fields: {\n    playMode: {type: 'int', size: 2},\n    beginLoop: AIFFMarkerIdField,\n    endLoop: AIFFMarkerIdField,\n  },\n});\n\n// typedef struct {\n//   char baseNote;\n//   char detune;\n//   char lowNote;\n//   char highNote;\n//   char lowVelocity;\n//   char highVelocity;\n//   short gain;\n//   Loop sustainLoop;\n//   Loop releaseLoop;\n// } InstrumentChunk;\nconst AIFFInstrumentStruct = new BufferStruct({\n  name: 'AIFFInstrument',\n  endian: 'big',\n  fields: {\n    baseNote: {type: 'int', size: 1},\n    detune: {type: 'int', size: 1},\n    lowNote: {type: 'int', size: 1},\n    highNote: {type: 'int', size: 1},\n    lowVelocity: {type: 'int', size: 1},\n    highVelocity: {type: 'int', size: 1},\n    gain: {type: 'int', size: 2},\n    sustainLoop: {type: AIFFLoopStruct},\n    releaseLoop: {type: AIFFLoopStruct},\n  },\n});\nconst AIFFNameChunkID = 'NAME'; /* ckID for Name Chunk */\nconst AIFFAuthorChunkID = 'AUTH'; /* ckID for Author Chunk */\nconst AIFFCopyrightChunkID = '(c) '; /* ckID for Copyright Chunk */\nconst AIFFAnnotationChunkID = 'ANNO'; /* ckID for Annotation Chunk */\n// typedef struct {\n//   ID ckID;\n//   long ckDataSize;\n//   char text[];\n// } TextChunk;\nconst AIFFTextStruct = new BufferStruct({\n  name: 'AIFFText',\n  endian: 'big',\n  fields: {\n    text: {type: 'utf8', size: (_, context) => context.dataSize},\n  },\n});\n\nconst AIFCVersion1 = 0xa2805140; /* Version 1 of AIFF-C */\n\nconst AIFCFormatStruct = new BufferStruct({\n  name: 'AIFCFormat',\n  endian: 'big',\n  fields: {\n    timestamp: {type: 'uint', size: 4},\n  },\n});\n\nfunction makeAIFFChunk(ckID, chunkData) {\n  return AIFFChunkStruct.serialize({\n    ckID,\n    ckSize: chunkData.length,\n    chunkData,\n  });\n}\n\nfunction serializeAIFF({\n  soundData,\n  numChannels,\n  sampleRate,\n  sampleSize,\n  form,\n  compressionType,\n  compressionName,\n  appl,\n}) {\n  const nsamples = Math.floor(\n    soundData.length / numChannels / (sampleSize / 8)\n  );\n  const sampleRate80Bit = Buffer.from(\n    ieeeExtended.ConvertToIeeeExtended(sampleRate)\n  );\n  DEBUG && console.log({sampleRate, sampleRate80Bit});\n\n  const formatChunk =\n    form === 'AIFC'\n      ? makeAIFFChunk(\n          'FVER',\n          AIFCFormatStruct.serialize({\n            timestamp: AIFCVersion1,\n          })\n        )\n      : null;\n\n  const commChunk = makeAIFFChunk(\n    'COMM',\n    form === 'AIFC'\n      ? AIFCCommonStruct.serialize({\n          numChannels,\n          numSampleFrames: nsamples,\n          sampleSize,\n          sampleRate: sampleRate80Bit,\n          compressionType,\n          compressionName,\n        })\n      : AIFFCommonStruct.serialize({\n          numChannels,\n          numSampleFrames: nsamples,\n          sampleSize,\n          sampleRate: sampleRate80Bit,\n        })\n  );\n\n  const soundDataChunk = makeAIFFChunk(\n    'SSND',\n    Buffer.concat([\n      AIFFSoundDataStruct.serialize(\n        {\n          offset: 0,\n          blockSize: 0,\n          soundData,\n        },\n        {\n          soundDataSize: soundData.length,\n        }\n      ),\n    ])\n  );\n\n  const applChunks =\n    form === 'AIFC' && appl\n      ? appl.map((applObj) =>\n          makeAIFFChunk(\n            'APPL',\n            Buffer.concat([\n              AIFCApplicationSpecificStruct.serialize(applObj, {\n                dataSize: applObj.data.length,\n              }),\n            ])\n          )\n        )\n      : [];\n\n  const formType = Buffer.from(form === 'AIFC' ? 'AIFC' : 'AIFF', 'utf8');\n\n  const aiffFileContents = makeAIFFChunk(\n    'FORM',\n    Buffer.concat(\n      [formType, formatChunk, commChunk, soundDataChunk, ...applChunks].filter(\n        Boolean\n      )\n    )\n  );\n\n  return aiffFileContents;\n}\n\nfunction parseAIFF(fileContents) {\n  let pos = 0;\n\n  let output = {};\n\n  const fileChunks = [];\n  while (pos < fileContents.length) {\n    DEBUG &&\n      console.error(\n        'parsing file chunk',\n        fileContents.slice(pos, pos + 4).toString('utf8'),\n        'at',\n        pos,\n        {fileContents}\n      );\n    const chunk = AIFFChunkStruct.parse(fileContents, pos);\n    chunk.startOffset = pos;\n    chunk.endOffset = AIFFChunkStruct.lastOffset;\n    fileChunks.push(chunk);\n    pos = AIFFChunkStruct.lastOffset;\n  }\n\n  DEBUG && console.log(fileChunks);\n\n  const formChunks = fileChunks.filter(\n    (fileChunk) => fileChunk.ckID === 'FORM'\n  );\n  formChunks.forEach((formChunk) => {\n    let pos = 0;\n    DEBUG && console.log('FORM chunk', formChunk);\n    formChunk.form = formChunk.chunkData.slice(0, 4).toString('utf8');\n    output.form = formChunk.form;\n    pos += 4; // skip FORM identifier\n    DEBUG && console.log({formID: formChunk.form});\n\n    const localChunks = [];\n    while (pos < formChunk.chunkData.length) {\n      DEBUG &&\n        console.error(\n          'parsing FORM local chunk',\n          formChunk.chunkData.slice(pos, pos + 4),\n          'at',\n          pos\n        );\n      const chunk = AIFFChunkStruct.parse(formChunk.chunkData, pos);\n      chunk.startOffset = pos;\n      chunk.endOffset = AIFFChunkStruct.lastOffset;\n\n      if (chunk.ckSize === 0) {\n        DEBUG &&\n          console.error(\n            'zero size chunk',\n            formChunk.chunkData.slice(pos, pos + 64)\n          );\n      }\n      switch (chunk.ckID) {\n        case 'COMM':\n          chunk.parsed =\n            formChunk.form === 'AIFC'\n              ? AIFCCommonStruct.parse(chunk.chunkData)\n              : AIFFCommonStruct.parse(chunk.chunkData);\n          chunk.parsed.sampleRate = ieeeExtended.ConvertFromIeeeExtended(\n            chunk.parsed.sampleRate\n          );\n          chunk.parsed = chunk.parsed;\n\n          output.sampleRate = chunk.parsed.sampleRate;\n          output.sampleSize = chunk.parsed.sampleSize;\n          output.numChannels = chunk.parsed.numChannels;\n          output.compressionType = chunk.parsed.compressionType;\n          output.compressionName = chunk.parsed.compressionName;\n          break;\n        case 'SSND':\n          chunk.parsed = AIFFSoundDataStruct.parse(chunk.chunkData, 0, {\n            soundDataSize:\n              chunk.ckSize - AIFF_SOUND_DATA_CHUNK_SIZE_EXCL_SOUNDDATA,\n          });\n          chunk.ssnd = chunk.parsed;\n          output.soundData = chunk.parsed.soundData;\n          break;\n        case 'MARK':\n          chunk.parsed = AIFFMarkerChunkStruct.parse(chunk.chunkData, 0);\n          break;\n        case 'COMT':\n          chunk.parsed = AIFFCommentStruct.parse(chunk.chunkData, 0);\n          break;\n        case 'INST':\n          chunk.parsed = AIFFInstrumentStruct.parse(chunk.chunkData, 0);\n          break;\n        case AIFFNameChunkID:\n        case AIFFAuthorChunkID:\n        case AIFFCopyrightChunkID:\n        case AIFFAnnotationChunkID:\n          chunk.parsed = AIFFTextStruct.parse(chunk.chunkData, 0, {\n            dataSize: chunk.ckSize,\n          });\n          break;\n        case 'APPL':\n          chunk.parsed = AIFCApplicationSpecificStruct.parse(\n            chunk.chunkData,\n            0,\n            {\n              dataSize: chunk.ckSize - AIFC_APPL_CHUNK_SIZE_EXCL_DATA,\n            }\n          );\n          chunk.appl = chunk.parsed;\n          output.appl = output.appl || [];\n          output.appl.push(chunk.parsed);\n          break;\n        case 'AIFC':\n          chunk.parsed = AIFCFormatStruct.parse(chunk.chunkData);\n          chunk.format = chunk.parsed;\n          break;\n        case 'FVER':\n          chunk.parsed = AIFCFormatStruct.parse(chunk.chunkData);\n          chunk.fver = chunk.parsed;\n          break;\n        default:\n          DEBUG && console.error('unknown chunk type', chunk.ckID);\n      }\n\n      DEBUG && console.log('local chunk', chunk);\n\n      localChunks.push(chunk);\n      pos = AIFFChunkStruct.lastOffset;\n    }\n    formChunk.localChunks = localChunks;\n  });\n  output.fileChunks = fileChunks;\n  output.formChunks = formChunks;\n  return output;\n}\n\nmodule.exports = {\n  serialize: serializeAIFF,\n  parse: parseAIFF,\n  PString,\n  AIFFLoopPlayMode,\n};\n","import React from 'react';\n\nexport default function Details({\n  summary,\n  children,\n  style,\n  summaryStyle,\n  startOpen,\n}) {\n  const [open, setOpen] = React.useState(startOpen);\n\n  const onToggle = React.useCallback(\n    (e) => {\n      e.preventDefault();\n      e.stopPropagation();\n      setOpen(!open);\n    },\n    [open]\n  );\n\n  return (\n    <details open={open} style={style}>\n      <summary onClick={onToggle} style={summaryStyle}>\n        {summary}\n      </summary>\n      {open && children}\n    </details>\n  );\n}\n","import { StrictMode } from \"react\";\nimport ReactDOM from \"react-dom\";\n\nimport App from \"./App\";\n\nconst rootElement = document.getElementById(\"root\");\nReactDOM.render(\n  <StrictMode>\n    <App />\n  </StrictMode>,\n  rootElement\n);\n","// https://en.cppreference.com/w/cpp/numeric/math/ldexp\nconst ldexp = (x, exp) => x * Math.pow(2, exp);\n\n// from https://raw.githubusercontent.com/locutusjs/locutus/master/src/c/math/frexp.js\n// license: https://github.com/locutusjs/locutus/blob/master/LICENSE\nfunction frexp(arg) {\n  arg = Number(arg);\n\n  const result = [arg, 0];\n\n  if (arg !== 0 && Number.isFinite(arg)) {\n    const absArg = Math.abs(arg);\n    // Math.log2 was introduced in ES2015, use it when available\n    const log2 =\n      Math.log2 ||\n      function log2(n) {\n        return Math.log(n) * Math.LOG2E;\n      };\n    let exp = Math.max(-1023, Math.floor(log2(absArg)) + 1);\n    let x = absArg * Math.pow(2, -exp);\n\n    // These while loops compensate for rounding errors that sometimes occur because of ECMAScript's Math.log2's undefined precision\n    // and also works around the issue of Math.pow(2, -exp) === Infinity when exp <= -1024\n    while (x < 0.5) {\n      x *= 2;\n      exp--;\n    }\n    while (x >= 1) {\n      x *= 0.5;\n      exp++;\n    }\n\n    if (arg < 0) {\n      x = -x;\n    }\n    result[0] = x;\n    result[1] = exp;\n  }\n  return result;\n}\n\n// this IEEE extended stuff comes from http://groovit.disjunkt.com/analog/specifs/ieee.c\n\n/*\n * C O N V E R T   T O   I E E E   E X T E N D E D\n */\n\nconst FloatToUnsigned = (f) => f - 2147483648.0 + 2147483647 + 1;\n\nfunction ConvertToIeeeExtended(/*double*/ num) {\n  let /*char**/ bytes = new Array(10).fill(0);\n  let /*int*/ sign;\n  let /*int*/ expon;\n  let /*double*/ fMant, fsMant;\n  let /*unsigned long*/ hiMant, loMant;\n\n  if (num < 0) {\n    sign = 0x8000;\n    num *= -1;\n  } else {\n    sign = 0;\n  }\n\n  if (num == 0) {\n    expon = 0;\n    hiMant = 0;\n    loMant = 0;\n  } else {\n    const frexpRes = frexp(num);\n    fMant = frexpRes[0];\n    expon = frexpRes[1];\n\n    if (expon > 16384 || !(fMant < 1)) {\n      /* Infinity or NaN */\n      expon = sign | 0x7fff;\n      hiMant = 0;\n      loMant = 0; /* infinity */\n    } else {\n      /* Finite */\n      expon += 16382;\n      if (expon < 0) {\n        /* denormalized */\n        fMant = ldexp(fMant, expon);\n        expon = 0;\n      }\n      expon |= sign;\n      fMant = ldexp(fMant, 32);\n      fsMant = Math.floor(fMant);\n      hiMant = FloatToUnsigned(fsMant);\n      fMant = ldexp(fMant - fsMant, 32);\n      fsMant = Math.floor(fMant);\n      loMant = FloatToUnsigned(fsMant);\n    }\n  }\n\n  bytes[0] = expon >> 8;\n  bytes[1] = expon;\n  bytes[2] = hiMant >> 24;\n  bytes[3] = hiMant >> 16;\n  bytes[4] = hiMant >> 8;\n  bytes[5] = hiMant;\n  bytes[6] = loMant >> 24;\n  bytes[7] = loMant >> 16;\n  bytes[8] = loMant >> 8;\n  bytes[9] = loMant;\n\n  return bytes;\n}\n\n/*\n * C O N V E R T   F R O M   I E E E   E X T E N D E D\n */\n\nconst UnsignedToFloat = (u) => ((u - 2147483647) | 0) - 1 + 2147483648.0;\n\n/****************************************************************\n * Extended precision IEEE floating-point conversion routine.\n ****************************************************************/\n\nfunction ConvertFromIeeeExtended(/*unsigned char**/ bytes /* LCN */) {\n  let /*double*/ f;\n  let /*int*/ expon;\n  let /*unsigned long*/ hiMant, loMant;\n\n  expon = ((bytes[0] & 0x7f) << 8) | (bytes[1] & 0xff);\n  hiMant =\n    ((bytes[2] & 0xff) << 24) |\n    ((bytes[3] & 0xff) << 16) |\n    ((bytes[4] & 0xff) << 8) |\n    (bytes[5] & 0xff);\n  loMant =\n    ((bytes[6] & 0xff) << 24) |\n    ((bytes[7] & 0xff) << 16) |\n    ((bytes[8] & 0xff) << 8) |\n    (bytes[9] & 0xff);\n\n  if (expon == 0 && hiMant == 0 && loMant == 0) {\n    f = 0;\n  } else {\n    if (expon == 0x7fff) {\n      /* Infinity or NaN */\n      f = Infinity;\n    } else {\n      expon -= 16383;\n      f = ldexp(UnsignedToFloat(hiMant), (expon -= 31));\n      f += ldexp(UnsignedToFloat(loMant), (expon -= 32));\n    }\n  }\n\n  if (bytes[0] & 0x80) return -f;\n  else return f;\n}\n\nmodule.exports = {\n  ConvertFromIeeeExtended,\n  ConvertToIeeeExtended\n};\n","const DEBUG = false;\n\nfunction nullthrows(value, message) {\n  if (value == null) {\n    throw new Error(\"unexpected null\" + (message ? \": \" + message : \"\"));\n  }\n  return value;\n}\n\nfunction nanthrows(value, message) {\n  if (isNaN(value)) {\n    throw new Error(\"unexpected NaN\" + (message ? \": \" + message : \"\"));\n  }\n  return value;\n}\n\nconst FieldTypesToBufferMethods = {\n  uint: \"UInt\",\n  int: \"Int\",\n  float: \"Float\",\n  double: \"Double\",\n  bigint: \"BigInt\",\n  biguint: \"BigUint\",\n  char: \"UInt\"\n};\n\nconst BytesTypes = new Set([\"bytes\", \"utf8\"]);\n\nfunction getBufferMethodName(type, size, endian) {\n  return `${FieldTypesToBufferMethods[type]}${size * 8}${\n    size == 1 ? \"\" : endian == \"big\" ? \"BE\" : \"LE\"\n  }`;\n}\n\nfunction getAlignedSize(size, alignment) {\n  return Math.ceil(size / alignment) * alignment;\n}\n\nfunction getAlignedSizeForField(field, size) {\n  return field.align != null\n    ? getAlignedSize(nanthrows(size), nanthrows(field.align))\n    : nanthrows(size);\n}\n\n/*\n  schema: an object mapping field names to a definition object.\n  definitions can have the following properties: \n  type: how to interpret the binary data. options:\n    uint -> number\n    int -> number\n    float -> number\n    double -> number\n    bigint -> BigInt\n    biguint -> BigInt\n    char -> number\n    bytes -> Buffer\n    utf8 -> string\n    BufferStructBase | BufferStruct | BufferStructUnion -> nested object\n  size: serialized field size in bytes\n  endian: endianness used when interpreting binary data\n  default: default value used when serializing if value not provided\n  size: size of field in bytes. can be fixed size or function determining size\n  arrayElements: treat this field as an array. function returning number of items\n  align: pad the field to a multiple of this number\n */\n\nclass BufferStructBase {\n  constructor(schema) {\n    this.schema = schema;\n    this.lastOffset = 0;\n  }\n\n  parse(buffer, startOffset, contextData = null) {\n    // should return value for this field and update this.lastOffset\n  }\n\n  serialize(data, contextData = null) {\n    // should return buffer of serialized data\n  }\n\n  getStaticSize() {\n    throw new Error(\n      \"getStaticSize not implemented on: \" + this.constructor.name\n    );\n  }\n\n  getName() {\n    return this.schema.name || this.constructor.name;\n  }\n}\n\nclass BufferStruct extends BufferStructBase {\n  parse(buffer, startOffset, contextData = null) {\n    const partialResult = {};\n    let offset = startOffset || 0;\n    Object.keys(this.schema.fields).forEach((fieldName) => {\n      const { field, endian, size, type } = this._getFieldConfig(\n        fieldName,\n        partialResult,\n        contextData\n      );\n\n      const parse = BytesTypes.has(type)\n        ? (buffer, startOffset) => {\n            if (size == null) {\n              throw new Error(\n                `can't parse field of type 'bytes' without predetermined size`\n              );\n            }\n            if (buffer.length < startOffset + size) {\n              throw new Error(\n                `tried to read ${size} bytes but only ${\n                  buffer.length - startOffset\n                } remaining for field ${fieldName} on ${this.getName()}`\n              );\n            }\n            const valueAsBuffer = buffer.slice(startOffset, startOffset + size);\n            let value = valueAsBuffer;\n            if (type === \"utf8\") {\n              value = valueAsBuffer.toString(\"utf8\");\n            }\n            return { value, parsedSize: size };\n          }\n        : type instanceof BufferStructBase\n        ? (buffer, startOffset) => {\n            // console.log('parsing', type.getName(), 'at', startOffset);\n            const value = type.parse(buffer, startOffset, contextData);\n            // use static size where determined (eg. in case of union)\n            const parsedSize =\n              size != null ? size : type.lastOffset - startOffset; // change in offset after parsing\n            // console.log({value, parsedSize});\n\n            return { value, parsedSize };\n          }\n        : (buffer, startOffset) => {\n            const methodName = `read${getBufferMethodName(type, size, endian)}`;\n\n            const value = buffer[methodName](startOffset);\n            if (this.schema.traceReads) {\n              console.log(methodName, {\n                fieldName,\n                type,\n                size,\n                endian,\n                startOffset,\n                value\n              });\n            }\n\n            return { value, parsedSize: size };\n          };\n\n      // the ability to provide predetermined size, as well as define alignment, means we need to account for either of these\n      // sources of padding when advancing the point we are reading in the buffer\n      const parseWithAlignment = (buffer, startOffset) => {\n        const { value, parsedSize } = parse(buffer, nanthrows(startOffset));\n\n        if (size != null && parsedSize > size) {\n          throw new Error(\n            `parsed size ${parsedSize} larger than predetermined size ${size} for field ${fieldName} on ${this.getName()}`\n          );\n        }\n\n        // when field is aligned we must make sure to advance by aligned size\n        // additionally, if a predetermined size is set, we should use that size instead (in case of padding)\n        // we have already asserted above that the parsed size is not larger than the predetermined size\n        let parsedSizeWithAlignment = getAlignedSizeForField(\n          field,\n          size != null ? size : parsedSize\n        );\n\n        if (size != null) {\n          const alignedExpectedSize = getAlignedSizeForField(field, size);\n\n          if (parsedSizeWithAlignment > alignedExpectedSize) {\n            throw new Error(\n              `aligned parsed size ${parsedSizeWithAlignment} larger than aligned predetermined size ${alignedExpectedSize} for field ${fieldName} on ${this.getName()}`\n            );\n          }\n        }\n\n        return { value, consumedSize: nanthrows(parsedSizeWithAlignment) };\n      };\n\n      // try {\n      if (field.arrayElements) {\n        // array field\n        const count =\n          typeof field.arrayElements === \"function\"\n            ? field.arrayElements(partialResult, contextData)\n            : field.arrayElements;\n        const array = new Array(count);\n\n        for (var i = 0; i < count; ++i) {\n          // console.log('getting array el', i, 'of', count, 'at', offset);\n          const { value, consumedSize } = parseWithAlignment(buffer, offset);\n\n          offset += nanthrows(consumedSize);\n          array[i] = value;\n        }\n\n        partialResult[fieldName] = array;\n      } else {\n        // non-array field\n        const { value, consumedSize } = parseWithAlignment(buffer, offset);\n        offset += nanthrows(consumedSize);\n        partialResult[fieldName] = value;\n      }\n      // } catch (error) {\n      //   throw new Error(\n      //     `failed parsing field ${fieldName} on ${this.getName()}: ${error}`\n      //   );\n      // }\n    });\n    if (isNaN(offset)) {\n      throw new Error(`invalid offset while parsing ${this.getName()}`);\n    }\n    this.lastOffset = offset;\n    return partialResult;\n  }\n\n  _getFieldConfig(fieldName, partialFieldData, contextData) {\n    const field = nullthrows(\n      this.schema.fields[fieldName],\n      `${fieldName} schema is missing`\n    );\n    const endian = field.endian || this.schema.endian || \"little\";\n    const type = nullthrows(field.type, `${fieldName} type`);\n    if (\n      !(\n        type instanceof BufferStructBase ||\n        type instanceof BufferStructUnion ||\n        type in FieldTypesToBufferMethods ||\n        BytesTypes.has(type)\n      )\n    ) {\n      throw new Error(`unsupported type ${type} in ${fieldName}`);\n    }\n\n    // use statically defined size if we've got it\n    let size =\n      typeof field.size === \"function\"\n        ? field.size(partialFieldData, contextData)\n        : field.size;\n    if (BytesTypes.has(type)) {\n      // allow size to be dynamic\n    } else if (type instanceof BufferStructBase) {\n      // allow size to be dynamic\n    } else if (type instanceof BufferStructUnion) {\n      // size will be statically known (asserted in BufferStructUnion)\n      size = type.size;\n    } else {\n      // size must be statically known\n      size = nullthrows(size, `${fieldName} size`);\n    }\n\n    let actualType = type;\n    // replace union type with actual type\n    if (type instanceof BufferStructUnion) {\n      actualType = type.selectMember(partialFieldData, contextData);\n      if (actualType == null) {\n        throw new Error(\n          `failed to refine union type in field ${fieldName} on ${this.getName()}`\n        );\n      }\n    }\n\n    return { field, endian, size, type: actualType };\n  }\n\n  serialize(data, contextData = null) {\n    if (!data) {\n      throw new Error(\n        `missing argument 'data' when serializing ${this.getName()}`\n      );\n    }\n    const parts = [];\n    Object.keys(this.schema.fields).forEach((fieldName) => {\n      const { field, endian, size, type } = this._getFieldConfig(\n        fieldName,\n        data,\n        contextData\n      );\n\n      let value;\n      if (!(fieldName in data)) {\n        if (\"default\" in field) {\n          value = field.default;\n        } else {\n          throw new Error(\n            `missing field ${fieldName} when serializing ${this.getName()}`\n          );\n        }\n      }\n      value = data[fieldName];\n\n      const serialize = BytesTypes.has(type)\n        ? (value) => {\n            let valueAsBuffer = value;\n            if (type === \"utf8\") {\n              valueAsBuffer = Buffer.from(value, \"utf8\");\n            }\n\n            const dynSize = size == null ? valueAsBuffer.length : size;\n            const partBuffer = Buffer.alloc(dynSize);\n            valueAsBuffer.copy(partBuffer, 0, 0, dynSize);\n\n            return partBuffer;\n          }\n        : type instanceof BufferStructBase\n        ? (value) => type.serialize(value, contextData)\n        : (value) => {\n            const methodName = `write${getBufferMethodName(\n              type,\n              size,\n              endian\n            )}`;\n\n            const partBuffer = Buffer.alloc(size);\n            partBuffer[methodName](value);\n            if (this.schema.traceWrites) {\n              console.log(methodName, {\n                fieldName,\n                type,\n                size,\n                endian,\n                value\n              });\n            }\n\n            return partBuffer;\n          };\n\n      const serializeWithAlignment = (value) => {\n        const partBuffer = serialize(value);\n        const serializedSize = partBuffer.length;\n        if (size != null && serializedSize > size) {\n          throw new Error(\n            `serialized size ${serializedSize} larger than predetermined size ${size} for field ${fieldName} on ${this.getName()}`\n          );\n        }\n\n        let maybeAlignedPartBuffer = partBuffer;\n        if (field.align != null) {\n          const alignedSerializedSize = getAlignedSize(\n            serializedSize,\n            field.align\n          );\n          const alignedExpectedSize = getAlignedSize(size, field.align);\n          if (alignedSerializedSize > alignedExpectedSize)\n            throw new Error(\n              `serialized aligned size ${\n                maybeAlignedPartBuffer.length\n              } larger than predetermined size (aligned) ${alignedExpectedSize} for field ${fieldName} on ${this.getName()}`\n            );\n\n          const partBufferAligned = Buffer.alloc(alignedSerializedSize);\n          partBuffer.copy(partBufferAligned);\n          maybeAlignedPartBuffer = partBufferAligned;\n        }\n\n        return maybeAlignedPartBuffer;\n      };\n\n      // try {\n      if (field.arrayElements) {\n        for (var i = 0; i < value.length; ++i) {\n          const part = serializeWithAlignment(value[i]);\n          parts.push(part);\n        }\n      } else {\n        const part = serializeWithAlignment(value);\n        parts.push(part);\n      }\n      // } catch (error) {\n      //   const extra = DEBUG ? `${error.stack} \\nrethrown stack:` : '';\n      //   throw new Error(\n      //     `failed serializing field ${fieldName}: ${error} ${extra}`\n      //   );\n      // }\n    });\n\n    return Buffer.concat(parts);\n  }\n\n  _staticSize = null;\n  getStaticSize() {\n    const prevSize = this._staticSize;\n    if (prevSize != null) {\n      return prevSize;\n    } else {\n      let size = 0;\n      for (const field of Object.values(this.schema.fields)) {\n        if (typeof field.size != \"number\") {\n          throw new Error(\n            \"cannot get static size of struct: \" + this.getName()\n          );\n        }\n        const alignedFieldSize = getAlignedSizeForField(field, field.size);\n        size += alignedFieldSize;\n      }\n      this._staticSize = size;\n      return size;\n    }\n  }\n}\n\n// simulates c struct union functionality, using the provided selectMember function\n// to choose which union member (BufferStruct) to interpret data as based on previously parsed fields.\n// requires that all union members have statically determinable size (eg. no arrays or dynamically sized bytes fields allowed)\n// when serializing, the maximum member size will be used\nclass BufferStructUnion {\n  constructor({ members, selectMember }) {\n    this.selectMember = selectMember;\n    this.members = members;\n    this.size = Math.max(...members.map((m) => m.getStaticSize()));\n  }\n}\n\nmodule.exports = {\n  BufferStruct,\n  BufferStructBase,\n  BufferStructUnion\n};\n"],"sourceRoot":""}